<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>The Finals Equipment Randomizer — Mega Rules</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --bg:#0b0b10; --card:#141420; --muted:#8b8ba0; --text:#e8e8ee; --ok:#7ce38b; --bad:#f7768e; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans"; background: var(--bg); color: var(--text);}
    header { padding: 16px 20px; display:flex; gap:12px; align-items:center; justify-content:space-between; border-bottom:1px solid #1e1e2a;}
    h1 { margin:0; font-size: clamp(18px, 3vw, 22px); letter-spacing: .2px; }
    .actions { display:flex; gap:10px; flex-wrap:wrap; }
    button { background: var(--card); border:1px solid #24243a; color: var(--text); padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600; transition: .15s transform ease, .15s background ease; }
    button:hover { transform: translateY(-1px); background:#1a1a2b; }
    button.secondary { background:transparent; }
    main { padding: 18px; max-width: 1200px; margin: 0 auto; display: grid; gap: 18px; }
    .row { display:grid; grid-template-columns: 1.2fr .8fr; gap:18px; }
    @media (max-width: 900px){ .row{ grid-template-columns:1fr; } }
    .card { background: var(--card); border:1px solid #1d1d2b; border-radius:16px; padding:16px; }
    .title { font-weight:700; margin: 0 0 8px; font-size: 18px; }
    .muted { color: var(--muted); font-size: 13px; }
    .rule { font-size: 16px; margin: 6px 0 10px; }
    .counts { display:flex; gap:12px; flex-wrap:wrap; }
    .pill { border:1px solid #2a2a40; padding:6px 10px; border-radius:999px; font-size: 12px; }
    .pill.ok { border-color:#2c4632; color: var(--ok);}
    .pill.bad { border-color:#51303a; color: var(--bad);}
    .grid { display:grid; gap:12px; grid-template-columns: repeat(3, 1fr); }
    @media (max-width: 900px){ .grid{ grid-template-columns:1fr; } }
    .group h3 { margin:0 0 6px; font-size: 15px; }
    ul { list-style:none; padding:0; margin:0; display:flex; flex-wrap:wrap; gap:6px; }
    li { background:#11111a; border:1px solid #1f1f30; padding:6px 8px; border-radius:10px; font-size: 13px; }
    .lists { display:grid; gap:12px; grid-template-columns: 1fr 1fr; }
    @media (max-width: 700px){ .lists{ grid-template-columns:1fr; } }
    .small { font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .error { color: var(--bad); }
    .success { color: var(--ok); }
  </style>
</head>
<body>
  <header>
    <h1>THE FINALS — Rule-Based Equipment Randomizer</h1>
    <div class="actions">
      <button id="newRuleBtn">Generate New Rule</button>
      <button id="resetCacheBtn" class="secondary">Reset Rules Cache</button>
    </div>
  </header>

  <main>
    <div class="row">
      <section class="card">
        <div class="title">Current Rule</div>
        <div id="ruleText" class="rule muted">Loading data…</div>
        <div class="counts">
          <span id="countAllowed" class="pill">Allowed: –</span>
          <span id="countBanned" class="pill">Banned: –</span>
          <span id="cacheInfo" class="pill">Seen rules: –</span>
        </div>
        <div class="small muted" style="margin-top:8px;">
          Balance constraints: <span class="mono">Allowed ≥ 20</span>, <span class="mono">Banned ≥ 25</span>. No per-class minimums.
        </div>
      </section>

      <section class="card">
        <div class="title">Notes</div>
        <p class="muted small">
          Rules are human-fast: letters, letter-pairs, starts/ends, digits, symbols, keywords, and simple combos (AND/OR). The generator tries many parameterizations and only keeps balanced, unused ones. Data is fetched live from your GitHub JSON.
        </p>
      </section>
    </div>

    <section class="card">
      <div class="title">Allowed Equipment (by Class & Category)</div>
      <div id="allowedWrap" class="grid"></div>
    </section>

    <section class="card">
      <div class="title">Banned (for reference)</div>
      <div id="bannedWrap" class="lists"></div>
      <p class="muted small" style="margin-top:10px">Players usually only need the rule & the allowed list.</p>
    </section>
  </main>

  <script>
    // ----------------------------
    // Config
    // ----------------------------
    const DATA_URL = "https://raw.githubusercontent.com/log2bits/the-finals-randomizer/refs/heads/main/data.json";
    const USED_RULES_KEY = "tfr_used_rules_v3";

    const MAX_RULE_ATTEMPTS = 1500;
    const MIN_ALLOWED = 20;
    const MIN_BANNED  = 20;

    const SYMBOLS = ["-", "'", "/", "+", "&", ".", "_"];
    const DIGITS  = ["0","1","2","3","4","5","6","7","8","9"];

    // ----------------------------
    // Utils
    // ----------------------------
    const rng = () => crypto.getRandomValues(new Uint32Array(1))[0] / 2**32;
    const sample = arr => arr[Math.floor(rng()*arr.length)];
    const shuffle = arr => arr.map(v=>[v, rng()]).sort((a,b)=>a[1]-b[1]).map(x=>x[0]);
    const unique = arr => Array.from(new Set(arr));
    const toKey = v => typeof v === "string" ? v : JSON.stringify(v);

    function kCombinations(arr, k){
      if(k <= 0 || k > arr.length) return [];
      const res = [];
      const pick = (start, path) => {
        if(path.length === k){ res.push(path.slice()); return; }
        for(let i=start; i<arr.length; i++) pick(i+1, path.concat(arr[i]));
      };
      pick(0, []);
      return res;
    }

    function loadUsedRules(){
      try { return new Set(JSON.parse(localStorage.getItem(USED_RULES_KEY) || "[]")); }
      catch { return new Set(); }
    }
    function saveUsedRules(set){
      localStorage.setItem(USED_RULES_KEY, JSON.stringify(Array.from(set)));
    }
    function resetUsedRules(){ localStorage.removeItem(USED_RULES_KEY); }

    // ----------------------------
    // Fetch / shape data
    // ----------------------------
    async function fetchData(){
      const res = await fetch(DATA_URL, {cache:"no-store"});
      if(!res.ok) throw new Error("Failed to fetch data.json from GitHub");
      return await res.json();
    }

    function flattenItems(builds){
      const out = [];
      for(const build of builds){
        const bName = build.build?.name || "Unknown";
        for(const cat of ["specializations","gadgets","weapons"]){
          for(const item of (build[cat] || [])){
            out.push({ buildName: bName, category: item.category, id: item.id, name: item.name });
          }
        }
      }
      return out;
    }
    function byBuildAndCategory(items){
      const map = {};
      for(const it of items){
        map[it.buildName] ??= {};
        map[it.buildName][it.category] ??= [];
        map[it.buildName][it.category].push(it);
      }
      return map;
    }

    // ----------------------------
    // Stats & tokenization
    // ----------------------------
    function makeLetterStats(items){
      const counts = {};
      const total = items.length;
      const names = items.map(i=>i.name.toLowerCase());
      for (let code=97; code<=122; code++){
        const ch = String.fromCharCode(code);
        counts[ch] = names.reduce((acc, n)=> acc + (n.includes(ch) ? 1 : 0), 0);
      }
      return {counts, total};
    }

    function makeBigramStats(items){
      const total = items.length;
      const names = items.map(i=>i.name.toLowerCase());
      const bigrams = new Map();
      const seenGlobal = new Set();
      for(const n of names){
        const s = n.replace(/[^a-z]/g, " ");
        const seenLocal = new Set();
        for(let i=0;i<s.length-1;i++){
          const a=s[i], b=s[i+1];
          if(/[a-z]/.test(a) && /[a-z]/.test(b)){
            seenLocal.add(a+b);
          }
        }
        for(const bg of seenLocal) seenGlobal.add(bg);
      }
      for(const bg of seenGlobal){
        let c = 0; for(const n of names) if(n.includes(bg)) c++;
        bigrams.set(bg, c);
      }
      return { counts: bigrams, total };
    }

    function extractKeywords(items, {minLen=3, maxCount=150} = {}){
      const counts = new Map();
      for(const it of items){
        const words = it.name.toLowerCase().split(/[^a-z0-9]+/g).filter(w => w.length >= minLen);
        const set = new Set(words); // count per-name presence
        for(const w of set){
          counts.set(w, (counts.get(w)||0)+1);
        }
      }
      // Sort by frequency and keep the head (but not everything—avoid super rare noise)
      const sorted = Array.from(counts.entries()).sort((a,b)=> b[1]-a[1]);
      return new Map(sorted.slice(0, maxCount)); // Map<word,count>
    }

    function presenceCounts(items, tokens, testFn){
      const counts = new Map();
      const total = items.length;
      for(const token of tokens){
        let c = 0;
        for(const it of items){
          if(testFn(it.name, token)) c++;
        }
        counts.set(token, c);
      }
      return { counts, total };
    }

    function pickNearHalfFrom(entries, total, mode){
      // entries: [token,count]
      const scored = entries.map(([token, c])=>{
        const allowed = (mode === "include") ? c : (total - c);
        return { token, allowed, score: Math.abs(allowed - total/2) };
      }).sort((a,b)=> a.score - b.score);
      // take a generous top slice to widen variety
      return scored.slice(0, 36).map(s=>s.token);
    }

    // ----------------------------
    // Quick checks (human-easy)
    // ----------------------------
    const hasAny = (s, arr) => {
      const t = s.toLowerCase();
      return arr.some(tok => t.includes(tok.toLowerCase()));
    };
    const excludesAll = (s, arr) => !hasAny(s, arr);
    const hasDigit = s => /\d/.test(s);
    const hasHyphen = s => s.includes("-");
    const hasApostrophe = s => s.includes("'");
    const hasSlash = s => s.includes("/");
    const hasPlus = s => s.includes("+");
    const hasAmp = s => s.includes("&");
    const hasDot = s => s.includes(".");
    const hasSpace = s => s.includes(" ");
    const singleWord = s => !hasSpace(s.trim());
    const startsWithVowel = s => /^[aeiou]/i.test(s.trim());
    const endsWithVowel = s => /[aeiou]$/i.test(s.trim());
    const startsWith = (s, ch) => s.trim().toLowerCase().startsWith(ch);
    const endsWith = (s, ch) => s.trim().toLowerCase().endsWith(ch);

    // ----------------------------
    // RULES
    // Each rule: { id, label(params), genParams(ctx), predicate(name, params) }
    // ----------------------------
    function listPretty(arr){ return arr.map(x => x.length===1 ? x.toUpperCase() : x).join(", "); }

    const BASE_RULES = [
      // 1) Letters (single, include/exclude)
      {
        id: "include_letter",
        label: p => `ALLOWED if the name contains the letter “${p.toUpperCase()}”.`,
        genParams: ctx => pickNearHalfFrom(Object.entries(ctx.letterStats.counts), ctx.letterStats.total, "include"),
        predicate: (name, p) => name.toLowerCase().includes(p),
      },
      {
        id: "exclude_letter",
        label: p => `ALLOWED if the name has NO letter “${p.toUpperCase()}”.`,
        genParams: ctx => pickNearHalfFrom(Object.entries(ctx.letterStats.counts), ctx.letterStats.total, "exclude"),
        predicate: (name, p) => !name.toLowerCase().includes(p),
      },

      // 2) Starts/Ends with single letter (and NOT starts/ends)
      {
        id: "starts_with_letter",
        label: ch => `ALLOWED if the name starts with “${ch.toUpperCase()}”.`,
        genParams: ctx => Object.keys(ctx.letterStats.counts),
        predicate: (name, ch) => startsWith(name, ch),
      },
      {
        id: "not_starts_with_letter",
        label: ch => `ALLOWED if the name does NOT start with “${ch.toUpperCase()}”.`,
        genParams: ctx => Object.keys(ctx.letterStats.counts),
        predicate: (name, ch) => !startsWith(name, ch),
      },
      {
        id: "ends_with_letter",
        label: ch => `ALLOWED if the name ends with “${ch.toUpperCase()}”.`,
        genParams: ctx => Object.keys(ctx.letterStats.counts),
        predicate: (name, ch) => endsWith(name, ch),
      },
      {
        id: "not_ends_with_letter",
        label: ch => `ALLOWED if the name does NOT end with “${ch.toUpperCase()}”.`,
        genParams: ctx => Object.keys(ctx.letterStats.counts),
        predicate: (name, ch) => !endsWith(name, ch),
      },

      // 3) Letter sets (any-of include/exclude)
      {
        id: "include_any_letters_set",
        label: set => `ALLOWED if the name has ANY of these letters: ${listPretty(set)}.`,
        genParams: ctx => shuffle([...kCombinations(Object.keys(ctx.letterStats.counts),2), ...kCombinations(Object.keys(ctx.letterStats.counts),3)]).slice(0,120),
        predicate: (name, set) => hasAny(name, set),
      },
      {
        id: "exclude_any_letters_set",
        label: set => `ALLOWED if the name has NONE of these letters: ${listPretty(set)}.`,
        genParams: ctx => shuffle([...kCombinations(Object.keys(ctx.letterStats.counts),2), ...kCombinations(Object.keys(ctx.letterStats.counts),3)]).slice(0,120),
        predicate: (name, set) => excludesAll(name, set),
      },

      // 4) Bigrams (letter pairs)
      {
        id: "include_bigram",
        label: p => `ALLOWED if the name contains the letter pair “${p}”.`,
        genParams: ctx => pickNearHalfFrom(Array.from(ctx.bigramStats.counts.entries()), ctx.bigramStats.total, "include"),
        predicate: (name, p) => name.toLowerCase().includes(p),
      },
      {
        id: "exclude_bigram",
        label: p => `ALLOWED if the name does NOT contain the letter pair “${p}”.`,
        genParams: ctx => pickNearHalfFrom(Array.from(ctx.bigramStats.counts.entries()), ctx.bigramStats.total, "exclude"),
        predicate: (name, p) => !name.toLowerCase().includes(p),
      },

      // 5) Digits & digit sets
      {
        id: "has_any_digit",
        label: () => "ALLOWED if the name has any number (0–9).",
        genParams: () => [true],
        predicate: (name) => /\d/.test(name),
      },
      {
        id: "has_digits_subset",
        label: set => `ALLOWED if the name has ANY of these numbers: ${set.join(", ")}.`,
        genParams: () => shuffle([...kCombinations(DIGITS,2), ...kCombinations(DIGITS,3), ...kCombinations(DIGITS,4)]).slice(0,120),
        predicate: (name, set) => hasAny(name, set),
      },

      // 6) Symbols & symbol sets
      {
        id: "has_any_symbol",
        label: () => `ALLOWED if the name has ANY of these symbols: ${SYMBOLS.join(" ")}`,
        genParams: () => [true],
        predicate: (name) => SYMBOLS.some(sym => name.includes(sym)),
      },
      {
        id: "has_symbols_subset",
        label: set => `ALLOWED if the name has ANY of these symbols: ${set.join(" ")}`,
        genParams: () => shuffle([...kCombinations(SYMBOLS,2), ...kCombinations(SYMBOLS,3)]).slice(0,80),
        predicate: (name, set) => set.some(sym => name.includes(sym)),
      },

      // 7) Word form
      {
        id: "single_word",
        label: () => "ALLOWED if the name is a single word (no spaces).",
        genParams: () => [true],
        predicate: (name) => singleWord(name),
      },
      {
        id: "multi_word",
        label: () => "ALLOWED if the name has 2+ words (has a space).",
        genParams: () => [true],
        predicate: (name) => hasSpace(name),
      },

      // 8) Vowel/consonant starts/ends (ultra fast)
      {
        id: "starts_with_vowel",
        label: () => "ALLOWED if the name starts with a vowel (A, E, I, O, U).",
        genParams: () => [true],
        predicate: (name) => startsWithVowel(name),
      },
      {
        id: "ends_with_vowel",
        label: () => "ALLOWED if the name ends with a vowel (A, E, I, O, U).",
        genParams: () => [true],
        predicate: (name) => endsWithVowel(name),
      },

      // 9) Keywords from dataset (include/exclude; combos)
      {
        id: "include_keyword",
        label: w => `ALLOWED if the name contains the word “${w}”.`,
        genParams: ctx => pickNearHalfFrom(Array.from(ctx.keywordStats.entries()), ctx.keywordStatsTotal, "include"),
        predicate: (name, w) => name.toLowerCase().includes(w),
      },
      {
        id: "exclude_keyword",
        label: w => `ALLOWED if the name does NOT contain the word “${w}”.`,
        genParams: ctx => pickNearHalfFrom(Array.from(ctx.keywordStats.entries()), ctx.keywordStatsTotal, "exclude"),
        predicate: (name, w) => !name.toLowerCase().includes(w),
      },
      {
        id: "include_any_keywords_set",
        label: set => `ALLOWED if the name has ANY of these words: ${set.join(", ")}.`,
        genParams: ctx => {
          const keys = Array.from(ctx.keywordStats.keys());
          const pools = [...kCombinations(keys,2), ...kCombinations(keys,3)];
          return shuffle(pools).slice(0, 120);
        },
        predicate: (name, set) => hasAny(name, set),
      },
      {
        id: "exclude_any_keywords_set",
        label: set => `ALLOWED if the name has NONE of these words: ${set.join(", ")}.`,
        genParams: ctx => {
          const keys = Array.from(ctx.keywordStats.keys());
          const pools = [...kCombinations(keys,2), ...kCombinations(keys,3)];
          return shuffle(pools).slice(0, 120);
        },
        predicate: (name, set) => excludesAll(name, set),
      },
    ];

    // Compound rule factory helpers (AND conditions)
    function compoundLabel(parts){
      return "ALLOWED if " + parts.join(" AND ");
    }
    function compoundRule(id, labelBuilder, paramGen, predicate){
      return { id, label: labelBuilder, genParams: paramGen, predicate };
    }

    function buildCompoundRules(ctx){
      // Use common keywords near 50/50 for good splits
      const candidateWords = pickNearHalfFrom(Array.from(ctx.keywordStats.entries()), ctx.keywordStatsTotal, "exclude"); // words to exclude
      const letters = Object.keys(ctx.letterStats.counts);

      const letterParams = letters.slice(0); // many
      const wordParams = shuffle(candidateWords).slice(0, 80);

      const rules = [];

      // A) "Does NOT contain <word> AND starts with a vowel"
      rules.push(compoundRule(
        "not_word_and_starts_vowel",
        p => compoundLabel([`the name does NOT contain “${p.word}”`, "it starts with a vowel"]),
        () => wordParams.map(w => ({word:w})),
        (name, p) => !name.toLowerCase().includes(p.word) && startsWithVowel(name)
      ));

      // B) "Does NOT contain <word> AND has ANY of digits {1,2,3}"
      const digitTriples = kCombinations(DIGITS.slice(1,4), 3); // [1,2,3]
      rules.push(compoundRule(
        "not_word_and_digits_subset",
        p => compoundLabel([`the name does NOT contain “${p.word}”`, `it has ANY of these numbers: ${p.digits.join(", ")}`]),
        () => wordParams.flatMap(w => digitTriples.map(digs => ({word:w, digits:digs}))),
        (name, p) => !name.toLowerCase().includes(p.word) && hasAny(name, p.digits)
      ));

      // C) "Does NOT contain <word> AND starts with letter X"
      rules.push(compoundRule(
        "not_word_and_starts_letter",
        p => compoundLabel([`the name does NOT contain “${p.word}”`, `it starts with “${p.letter.toUpperCase()}”`]),
        () => wordParams.flatMap(w => shuffle(letterParams).slice(0,10).map(l => ({word:w, letter:l}))),
        (name, p) => !name.toLowerCase().includes(p.word) && startsWith(name, p.letter)
      ));

      // D) "Does NOT contain <word> AND ends with letter X"
      rules.push(compoundRule(
        "not_word_and_ends_letter",
        p => compoundLabel([`the name does NOT contain “${p.word}”`, `it ends with “${p.letter.toUpperCase()}”`]),
        () => wordParams.flatMap(w => shuffle(letterParams).slice(0,10).map(l => ({word:w, letter:l}))),
        (name, p) => !name.toLowerCase().includes(p.word) && endsWith(name, p.letter)
      ));

      // E) "Single word AND has symbol subset (any-of)"
      const symSets = shuffle([...kCombinations(SYMBOLS,2), ...kCombinations(SYMBOLS,3)]).slice(0, 40);
      rules.push(compoundRule(
        "single_word_and_symbols_subset",
        p => compoundLabel(["the name is a single word", `it has ANY of these symbols: ${p.syms.join(" ")}`]),
        () => symSets.map(syms => ({syms})),
        (name, p) => singleWord(name) && p.syms.some(sym => name.includes(sym))
      ));

      // F) "Multi-word AND has letter pair (bigram)"
      const topBigrams = pickNearHalfFrom(Array.from(ctx.bigramStats.counts.entries()), ctx.bigramStats.total, "include").slice(0, 20);
      rules.push(compoundRule(
        "multi_word_and_bigram",
        p => compoundLabel(["the name has 2+ words", `it contains “${p.bg}”`]),
        () => topBigrams.map(bg => ({bg})),
        (name, p) => hasSpace(name) && name.toLowerCase().includes(p.bg)
      ));

      return rules;
    }

    // ----------------------------
    // Rule engine
    // ----------------------------
    function ruleKey(ruleId, params){
      const normalized = Array.isArray(params) ? [...params].sort() : (typeof params === "object" && params ? Object.keys(params).sort().reduce((o,k)=> (o[k]=params[k], o), {}) : params);
      return `${ruleId}::${toKey(normalized)}`;
    }

    function partition(items, predicate, params){
      const allowed=[], banned=[];
      for(const it of items){
        (predicate(it.name, params) ? allowed : banned).push(it);
      }
      return {allowed, banned};
    }
    function meetsGlobalBalance(a, b){ return a >= MIN_ALLOWED && b >= MIN_BANNED; }

    // ----------------------------
    // Rendering
    // ----------------------------
    function renderLists(allowed, banned){
      const byBuild = {};
      for(const it of allowed){
        byBuild[it.buildName] ??= { specialization:[], gadget:[], weapon:[] };
        byBuild[it.buildName][it.category].push(it);
      }
      const allowedWrap = document.getElementById("allowedWrap");
      allowedWrap.innerHTML = "";
      for(const buildName of Object.keys(byBuild)){
        const sect = document.createElement("div"); sect.className="group";
        sect.innerHTML = `<h3>${buildName}</h3>
          <div class="lists">
            <div><div class="muted small">Specializations</div><ul>${byBuild[buildName].specialization.map(i=>`<li title="${i.id}">${i.name}</li>`).join("")}</ul></div>
            <div><div class="muted small">Gadgets</div><ul>${byBuild[buildName].gadget.map(i=>`<li title="${i.id}">${i.name}</li>`).join("")}</ul></div>
            <div><div class="muted small">Weapons</div><ul>${byBuild[buildName].weapon.map(i=>`<li title="${i.id}">${i.name}</li>`).join("")}</ul></div>
          </div>`;
        allowedWrap.appendChild(sect);
      }

      const bannedWrap = document.getElementById("bannedWrap");
      const half = Math.ceil(banned.length/2);
      const colA = banned.slice(0, half), colB = banned.slice(half);
      bannedWrap.innerHTML = `
        <div>
          <div class="muted small">Banned (A)</div>
          <ul>${colA.map(i=>`<li title="${i.buildName} / ${i.category}">${i.name}</li>`).join("")}</ul>
        </div>
        <div>
          <div class="muted small">Banned (B)</div>
          <ul>${colB.map(i=>`<li title="${i.buildName} / ${i.category}">${i.name}</li>`).join("")}</ul>
        </div>
      `;
    }
    function showCounts(a, b){
      const A = document.getElementById("countAllowed");
      const B = document.getElementById("countBanned");
      A.textContent = `Allowed: ${a}`;
      B.textContent = `Banned: ${b}`;
      A.className = `pill ${a>=MIN_ALLOWED ? "ok":"bad"}`;
      B.className = `pill ${b>=MIN_BANNED ? "ok":"bad"}`;
    }

    // ----------------------------
    // Generator
    // ----------------------------
    async function generateRuleAndRender(builds){
      const items = flattenItems(builds);

      // Build stats
      const letterStats = makeLetterStats(items);
      const bigramStats = makeBigramStats(items);
      const keywordStats = extractKeywords(items); // Map<word,count>
      const ctx = {
        items,
        letterStats,
        bigramStats,
        keywordStats,
        keywordStatsTotal: items.length
      };

      // Assemble rules list (base + dynamic compound)
      const RULES = [...BASE_RULES, ...buildCompoundRules(ctx)];

      const used = loadUsedRules();
      const ruleOrder = shuffle([...RULES]);

      let chosen = null, chosenParams = null, part = null;

      outer:
      for(let attempts = 0; attempts < MAX_RULE_ATTEMPTS; attempts++){
        const rule = sample(ruleOrder);
        const paramsList = shuffle(rule.genParams(ctx));
        for(const p of paramsList){
          const key = ruleKey(rule.id, p);
          if(used.has(key)) continue;

          const res = partition(items, rule.predicate, p);
          if(!meetsGlobalBalance(res.allowed.length, res.banned.length)) continue;

          chosen = rule; chosenParams = p; part = res;
          used.add(key); saveUsedRules(used);
          break outer;
        }
      }

      const ruleText = document.getElementById("ruleText");
      const cacheInfo = document.getElementById("cacheInfo");
      cacheInfo.textContent = `Seen rules: ${loadUsedRules().size}`;

      if(!chosen){
        ruleText.innerHTML = `<span class="error">Couldn’t find a new balanced rule. Hit “Reset Rules Cache” or click again.</span>`;
        showCounts(0,0);
        renderLists([],[]);
        return;
      }

      ruleText.textContent = chosen.label(chosenParams);
      showCounts(part.allowed.length, part.banned.length);
      renderLists(part.allowed, part.banned);
    }

    // ----------------------------
    // UI
    // ----------------------------
    document.getElementById("newRuleBtn").addEventListener("click", async ()=>{
      try{
        document.getElementById("ruleText").textContent = "Finding a fresh, balanced rule…";
        await generateRuleAndRender(window.__DATA_BUILDS || []);
      }catch(err){
        document.getElementById("ruleText").innerHTML = `<span class="error">Error: ${err.message}</span>`;
      }
    });
    document.getElementById("resetCacheBtn").addEventListener("click", ()=>{
      resetUsedRules();
      document.getElementById("cacheInfo").textContent = "Seen rules: 0";
    });

    // ----------------------------
    // Init
    // ----------------------------
    (async function init(){
      try{
        const data = await fetchData();
        window.__DATA_BUILDS = Array.isArray(data) ? data : [];
        document.getElementById("ruleText").textContent = "Generating…";
        await generateRuleAndRender(window.__DATA_BUILDS);
      }catch(err){
        document.getElementById("ruleText").innerHTML = `<span class="error">Failed to load data: ${err.message}</span>`;
      }
    })();
  </script>
</body>
</html>
