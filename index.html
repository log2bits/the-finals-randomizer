<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>The Finals Equipment Randomizer (Rule-Based)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --bg:#0b0b10; --card:#141420; --muted:#8b8ba0; --text:#e8e8ee; --accent:#7aa2f7; --ok:#7ce38b; --bad:#f7768e; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji"; background: var(--bg); color: var(--text);}
    header { padding: 16px 20px; display:flex; gap:12px; align-items:center; justify-content:space-between; border-bottom:1px solid #1e1e2a;}
    h1 { margin:0; font-size: clamp(18px, 3vw, 22px); letter-spacing: .2px; }
    .actions { display:flex; gap:10px; flex-wrap:wrap; }
    button { background: var(--card); border:1px solid #24243a; color: var(--text); padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600; transition: .15s transform ease, .15s background ease; }
    button:hover { transform: translateY(-1px); background:#1a1a2b; }
    button.secondary { background:transparent; }
    main { padding: 18px; max-width: 1200px; margin: 0 auto; display: grid; gap: 18px; }
    .row { display:grid; grid-template-columns: 1.2fr .8fr; gap:18px; }
    @media (max-width: 900px){ .row{ grid-template-columns:1fr; } }
    .card { background: var(--card); border:1px solid #1d1d2b; border-radius:16px; padding:16px; }
    .title { font-weight:700; margin: 0 0 8px; font-size: 18px; }
    .muted { color: var(--muted); font-size: 13px; }
    .rule { font-size: 16px; margin: 6px 0 10px; }
    .counts { display:flex; gap:12px; flex-wrap:wrap; }
    .pill { border:1px solid #2a2a40; padding:6px 10px; border-radius:999px; font-size: 12px; }
    .pill.ok { border-color:#2c4632; color: var(--ok);}
    .pill.bad { border-color:#51303a; color: var(--bad);}
    .grid { display:grid; gap:12px; grid-template-columns: repeat(3, 1fr); }
    @media (max-width: 900px){ .grid{ grid-template-columns:1fr; } }
    .group h3 { margin:0 0 6px; font-size: 15px; }
    ul { list-style:none; padding:0; margin:0; display:flex; flex-wrap:wrap; gap:6px; }
    li { background:#11111a; border:1px solid #1f1f30; padding:6px 8px; border-radius:10px; font-size: 13px; }
    .legend { display:flex; gap:10px; flex-wrap:wrap; }
    .legend .tag { font-size:12px; border:1px dashed #2a2a40; padding:4px 8px; border-radius:999px;}
    .small { font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .footer { color: var(--muted); font-size: 12px; text-align:center; padding: 12px 0 20px; }
    .error { color: var(--bad); }
    .success { color: var(--ok); }
    details { border:1px solid #23233a; border-radius:12px; padding:8px 12px; }
    details[open] { background:#101019; }
    summary { cursor:pointer; font-weight:600; margin:6px 0; }
    .lists { display:grid; gap:12px; grid-template-columns: 1fr 1fr; }
    @media (max-width: 700px){ .lists{ grid-template-columns:1fr; } }
    .nowrap { white-space: nowrap; }
  </style>
</head>
<body>
  <header>
    <h1>THE FINALS – Rule-Based Equipment Randomizer</h1>
    <div class="actions">
      <button id="newRuleBtn">Generate New Rule</button>
      <button id="resetCacheBtn" class="secondary">Reset Rules Cache</button>
    </div>
  </header>

  <main>
    <div class="row">
      <section class="card">
        <div class="title">Current Rule</div>
        <div id="ruleText" class="rule muted">Loading data…</div>
        <div class="counts">
          <span id="countAllowed" class="pill">Allowed: –</span>
          <span id="countBanned" class="pill">Banned: –</span>
          <span id="cacheInfo" class="pill">Seen rules: –</span>
        </div>
        <div class="legend" style="margin-top:10px">
          <span class="tag">Guarantee: <span class="nowrap mono">≥1</span> weapon per class</span>
          <span class="tag">Also: at least <span class="mono">20</span> allowed & <span class="mono">25</span> banned overall</span>
        </div>
        <div id="status" class="small" style="margin-top:8px;"></div>
      </section>

      <section class="card">
        <div class="title">Controls</div>
        <p class="muted small">Rules are intentionally simple for humans to apply quickly (letters, letter-pairs, digits, hyphens, spaces). The generator tries multiple rules until it finds a balanced one you haven’t used yet.</p>
        <details>
          <summary>How rules work (dev notes)</summary>
          <ul class="small">
            <li>Modular: add rules in <span class="mono">RULES</span>.</li>
            <li>Each rule defines <span class="mono">genParams(ctx)</span> and <span class="mono">predicate(name, params)</span>.</li>
            <li>We auto-discover frequent <b>bigrams</b> and pick ones near 50/50 splits.</li>
            <li>Uniqueness via <span class="mono">localStorage["tfr_used_rules_v1"]</span>.</li>
          </ul>
        </details>
      </section>
    </div>

    <section class="card">
      <div class="title">Allowed Equipment (by Class & Category)</div>
      <div id="allowedWrap" class="grid"></div>
    </section>

    <section class="card">
      <div class="title">Banned (for reference)</div>
      <div id="bannedWrap" class="lists"></div>
      <p class="muted small" style="margin-top:10px">You rarely need to read this—players only need the rule & allowed list.</p>
    </section>
  </main>

  <div class="footer">Made for quick, unique lobbies. Add your own rules in the source. Data loads from your GitHub JSON.</div>

  <script>
    // ----------------------------
    // Config
    // ----------------------------
    const USED_RULES_KEY = "tfr_used_rules_v1";
    const MAX_RULE_ATTEMPTS = 600; // more tries for more variety
    const MIN_ALLOWED = 20;        // ↓ from 25
    const MIN_BANNED  = 20;        // keep meaningful bans

    // Only guarantee ≥1 weapon per class
    const MIN_PER_CLASS = { weapon: 1 };

    // ----------------------------
    // Utilities
    // ----------------------------
    const sample = arr => arr[Math.floor(crypto.getRandomValues(new Uint32Array(1))[0] / 2**32 * arr.length)];
    const shuffle = arr => arr.map(v=>[v, crypto.getRandomValues(new Uint32Array(1))[0]]).sort((a,b)=>a[1]-b[1]).map(x=>x[0]);

    function loadUsedRules(){
      try { return new Set(JSON.parse(localStorage.getItem(USED_RULES_KEY) || "[]")); }
      catch { return new Set(); }
    }
    function saveUsedRules(set){
      localStorage.setItem(USED_RULES_KEY, JSON.stringify(Array.from(set)));
    }
    function resetUsedRules(){ localStorage.removeItem(USED_RULES_KEY); }

    // ----------------------------
    // Fetch data
    // ----------------------------
    const DATA_URL = "https://raw.githubusercontent.com/log2bits/the-finals-randomizer/refs/heads/main/data.json";
    async function fetchData(){
      const res = await fetch(DATA_URL, {cache:"no-store"});
      if(!res.ok) throw new Error("Failed to fetch data.json from GitHub");
      return await res.json();
    }

    // ----------------------------
    // Data helpers
    // ----------------------------
    function flattenItems(builds){
      const out = [];
      for(const build of builds){
        const bName = build.build?.name || "Unknown";
        for(const cat of ["specializations","gadgets","weapons"]){
          for(const item of (build[cat] || [])){
            out.push({ buildName: bName, category: item.category, id: item.id, name: item.name });
          }
        }
      }
      return out;
    }
    function byBuildAndCategory(items){
      const map = {};
      for(const it of items){
        map[it.buildName] ??= {};
        map[it.buildName][it.category] ??= [];
        map[it.buildName][it.category].push(it);
      }
      return map;
    }

    // ----------------------------
    // Stats for letters & bigrams
    // ----------------------------
    function makeLetterStats(items){
      const counts = {};
      const total = items.length;
      const names = items.map(i=>i.name.toLowerCase());
      for (let code=97; code<=122; code++){
        const ch = String.fromCharCode(code);
        counts[ch] = names.reduce((acc, n)=> acc + (n.includes(ch) ? 1 : 0), 0);
      }
      return {counts, total};
    }

    function makeBigramStats(items){
      const total = items.length;
      const names = items.map(i=>i.name.toLowerCase());
      const bigrams = new Map();
      // Collect unique bigrams present in this dataset (letters only for human ease)
      const seenSet = new Set();
      for(const n of names){
        const lettersOnly = n.replace(/[^a-z]/g, " ");
        const seenInThisName = new Set();
        for(let i=0;i<lettersOnly.length-1;i++){
          const a = lettersOnly[i], b = lettersOnly[i+1];
          if(/[a-z]/.test(a) && /[a-z]/.test(b)){
            const bg = a+b;
            seenInThisName.add(bg);
          }
        }
        for(const bg of seenInThisName) seenSet.add(bg);
      }
      // Count presence
      for(const bg of seenSet){
        let c = 0;
        for(const n of names) if(n.includes(bg)) c++;
        bigrams.set(bg, c);
      }
      return { counts: bigrams, total };
    }

    function pickNearHalfFromCounts(countsObjOrMap, total, mode){
      // counts can be an object (letters) or Map (bigrams)
      const entries = countsObjOrMap instanceof Map
        ? Array.from(countsObjOrMap.entries())
        : Object.entries(countsObjOrMap);
      const scored = entries.map(([token, c])=>{
        const allowedIfInclude = c;
        const allowedIfExclude = total - c;
        const allowed = (mode === "include") ? allowedIfInclude : allowedIfExclude;
        const score = Math.abs(allowed - total/2);
        return { token, allowed, score };
      });
      scored.sort((a,b)=> a.score - b.score);
      // return a handful of strong 50/50 candidates
      return scored.slice(0, 18).map(s=>s.token);
    }

    // ----------------------------
    // Quick checks
    // ----------------------------
    const hasDigit = s => /\d/.test(s);
    const hasHyphen = s => s.includes("-");
    const hasApostrophe = s => s.includes("'");
    const hasSpace = s => s.includes(" ");
    const startsWithVowel = s => /^[aeiou]/i.test(s.trim());
    const endsWithVowel = s => /[aeiou]$/i.test(s.trim());

    // ----------------------------
    // Rules (modular)
    // ----------------------------
    const RULES = [
      // Letter presence (generic)
      {
        id: "include_letter",
        label: p => `ALLOWED if the name has the letter “${p}” (case-insensitive).`,
        genParams: ctx => pickNearHalfFromCounts(ctx.letterStats.counts, ctx.letterStats.total, "include"),
        predicate: (name, p) => name.toLowerCase().includes(p),
      },
      {
        id: "exclude_letter",
        label: p => `ALLOWED if the name has NO letter “${p}”.`,
        genParams: ctx => pickNearHalfFromCounts(ctx.letterStats.counts, ctx.letterStats.total, "exclude"),
        predicate: (name, p) => !name.toLowerCase().includes(p),
      },

      // Bigram (letter-pair) presence (auto-discovered, near 50/50)
      {
        id: "include_bigram",
        label: p => `ALLOWED if the name contains the letter pair “${p}”.`,
        genParams: ctx => pickNearHalfFromCounts(ctx.bigramStats.counts, ctx.bigramStats.total, "include"),
        predicate: (name, p) => name.toLowerCase().includes(p),
      },
      {
        id: "exclude_bigram",
        label: p => `ALLOWED if the name does NOT contain the letter pair “${p}”.`,
        genParams: ctx => pickNearHalfFromCounts(ctx.bigramStats.counts, ctx.bigramStats.total, "exclude"),
        predicate: (name, p) => !name.toLowerCase().includes(p),
      },

      // Simple symbol/digit flags
      {
        id: "has_digit",
        label: () => "ALLOWED if the name has any number (0–9).",
        genParams: () => [true],
        predicate: (name) => hasDigit(name),
      },
      {
        id: "has_hyphen",
        label: () => "ALLOWED if the name has a hyphen (–).",
        genParams: () => [true],
        predicate: (name) => hasHyphen(name),
      },
      {
        id: "has_apostrophe",
        label: () => "ALLOWED if the name has an apostrophe (’).",
        genParams: () => [true],
        predicate: (name) => hasApostrophe(name),
      },
      {
        id: "has_space",
        label: () => "ALLOWED if the name contains a space.",
        genParams: () => [true],
        predicate: (name) => hasSpace(name),
      },

      // Vowel start/end (very fast for humans)
      {
        id: "starts_with_vowel",
        label: () => "ALLOWED if the name starts with a vowel (A, E, I, O, U).",
        genParams: () => [true],
        predicate: (name) => startsWithVowel(name),
      },
      {
        id: "ends_with_vowel",
        label: () => "ALLOWED if the name ends with a vowel (A, E, I, O, U).",
        genParams: () => [true],
        predicate: (name) => endsWithVowel(name),
      },
    ];

    function ruleKey(ruleId, params){ return `${ruleId}::${JSON.stringify(params)}`; }

    // ----------------------------
    // Selection / constraints
    // ----------------------------
    function partition(items, predicate, params){
      const allowed=[], banned=[];
      for(const it of items){
        (predicate(it.name, params) ? allowed : banned).push(it);
      }
      return {allowed, banned};
    }
    function meetsGlobalBalance(allowedCount, bannedCount){
      return allowedCount >= MIN_ALLOWED && bannedCount >= MIN_BANNED;
    }

    function meetsPerClassMinimums(allowedItems){
      // Only enforce ≥1 weapon per class now
      const map = byBuildAndCategory(allowedItems);
      const buildsPresent = window.__ALL_BUILD_NAMES || [];
      for(const b of buildsPresent){
        const cats = map[b] || {};
        const haveWeapons = (cats.weapon?.length || 0);
        if (haveWeapons < (MIN_PER_CLASS.weapon || 0)) return false;
      }
      return true;
    }

    // ----------------------------
    // Rendering
    // ----------------------------
    function renderLists(allowed, banned){
      const byBuild = {};
      for(const it of allowed){
        byBuild[it.buildName] ??= { specialization:[], gadget:[], weapon:[] };
        byBuild[it.buildName][it.category].push(it);
      }
      const allowedWrap = document.getElementById("allowedWrap");
      allowedWrap.innerHTML = "";
      for(const buildName of Object.keys(byBuild)){
        const sect = document.createElement("div"); sect.className="group";
        sect.innerHTML = `<h3>${buildName}</h3>
          <div class="lists">
            <div><div class="muted small">Specializations</div><ul>${byBuild[buildName].specialization.map(i=>`<li title="${i.id}">${i.name}</li>`).join("")}</ul></div>
            <div><div class="muted small">Gadgets</div><ul>${byBuild[buildName].gadget.map(i=>`<li title="${i.id}">${i.name}</li>`).join("")}</ul></div>
            <div><div class="muted small">Weapons</div><ul>${byBuild[buildName].weapon.map(i=>`<li title="${i.id}">${i.name}</li>`).join("")}</ul></div>
          </div>`;
        allowedWrap.appendChild(sect);
      }

      const bannedWrap = document.getElementById("bannedWrap");
      const half = Math.ceil(banned.length/2);
      const colA = banned.slice(0, half), colB = banned.slice(half);
      bannedWrap.innerHTML = `
        <div>
          <div class="muted small">Banned (A)</div>
          <ul>${colA.map(i=>`<li title="${i.buildName} / ${i.category}">${i.name}</li>`).join("")}</ul>
        </div>
        <div>
          <div class="muted small">Banned (B)</div>
          <ul>${colB.map(i=>`<li title="${i.buildName} / ${i.category}">${i.name}</li>`).join("")}</ul>
        </div>
      `;
    }
    function showCounts(allowedCount, bannedCount, okPerClass){
      const a = document.getElementById("countAllowed");
      const b = document.getElementById("countBanned");
      a.textContent = `Allowed: ${allowedCount}`;
      b.textContent = `Banned: ${bannedCount}`;
      a.className = `pill ${allowedCount>=MIN_ALLOWED ? "ok":"bad"}`;
      b.className = `pill ${bannedCount>=MIN_BANNED ? "ok":"bad"}`;
      const status = document.getElementById("status");
      status.innerHTML = okPerClass
        ? `<span class="success">All per-class weapon minimums satisfied.</span>`
        : `<span class="error">Per-class weapon minimums NOT satisfied.</span>`;
    }

    // ----------------------------
    // Generator
    // ----------------------------
    async function generateRuleAndRender(builds){
      const items = flattenItems(builds);
      const allBuildNames = builds.map(b=>b.build?.name).filter(Boolean);
      window.__ALL_BUILD_NAMES = allBuildNames;

      const ctx = {
        letterStats: makeLetterStats(items),
        bigramStats: makeBigramStats(items),
        items
      };

      const used = loadUsedRules();
      const ruleOrder = shuffle([...RULES]);
      let chosen = null, chosenParams = null, part = null;

      outer:
      for(let attempts = 0; attempts < MAX_RULE_ATTEMPTS; attempts++){
        const rule = sample(ruleOrder);
        const paramsList = shuffle(rule.genParams(ctx));
        for(const p of paramsList){
          const key = ruleKey(rule.id, p);
          if(used.has(key)) continue;

          const res = partition(items, rule.predicate, p);
          if(!meetsGlobalBalance(res.allowed.length, res.banned.length)) continue;
          if(!meetsPerClassMinimums(res.allowed)) continue;

          chosen = rule; chosenParams = p; part = res;
          used.add(key);
          saveUsedRules(used);
          break outer;
        }
      }

      const ruleText = document.getElementById("ruleText");
      const cacheInfo = document.getElementById("cacheInfo");
      cacheInfo.textContent = `Seen rules: ${loadUsedRules().size}`;

      if(!chosen){
        ruleText.innerHTML = `<span class="error">Couldn’t find a new balanced rule. Try “Reset Rules Cache” and generate again.</span>`;
        showCounts(0,0,false);
        renderLists([],[]);
        return;
      }

      ruleText.textContent = chosen.label(chosenParams);
      showCounts(part.allowed.length, part.banned.length, true);
      renderLists(part.allowed, part.banned);
    }

    // ----------------------------
    // Wire up UI
    // ----------------------------
    document.getElementById("newRuleBtn").addEventListener("click", async ()=>{
      try{
        document.getElementById("ruleText").textContent = "Thinking up a balanced rule…";
        const builds = window.__DATA_BUILDS || [];
        await generateRuleAndRender(builds);
      }catch(err){
        document.getElementById("ruleText").innerHTML = `<span class="error">Error: ${err.message}</span>`;
      }
    });

    document.getElementById("resetCacheBtn").addEventListener("click", ()=>{
      resetUsedRules();
      document.getElementById("cacheInfo").textContent = "Seen rules: 0";
    });

    // ----------------------------
    // Init
    // ----------------------------
    (async function init(){
      try{
        const data = await fetchData();
        window.__DATA_BUILDS = Array.isArray(data) ? data : [];
        document.getElementById("ruleText").textContent = "Generating...";
        await generateRuleAndRender(window.__DATA_BUILDS);
      }catch(err){
        document.getElementById("ruleText").innerHTML = `<span class="error">Failed to load data: ${err.message}</span>`;
      }
    })();
  </script>
</body>
</html>
