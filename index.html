<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>The Finals Equipment Randomizer — Final Version</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg:#0b0b10; --card:#141420; --muted:#8b8ba0; --text:#e8e8ee;
      --ok:#7ce38b; --bad:#f7768e; --border:#1d1d2b; --accent:#7aa2f7;
    }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Inter, Roboto, Arial; background: var(--bg); color: var(--text);}
    header { padding: 16px 20px; display:flex; gap:12px; align-items:center; justify-content:space-between; border-bottom:1px solid #1e1e2a;}
    h1 { margin:0; font-size: clamp(18px, 3vw, 22px); letter-spacing:.2px; }
    .actions { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button {
      background: var(--card); border:1px solid #24243a; color: var(--text);
      padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600;
      transition: .15s transform ease, .15s background ease, .15s opacity ease;
    }
    button:hover { transform: translateY(-1px); background:#1a1a2b; }
    button.secondary { background:transparent; }
    button:disabled { opacity:.6; cursor:not-allowed; transform:none; }
    .share {
      display:flex; gap:8px; align-items:center; background:#0f0f17; border:1px solid #23233a;
      border-radius:12px; padding:6px 10px;
    }
    .share input {
      width: 320px; max-width: 52vw; background:transparent; color:var(--text);
      border:none; outline:none; font-size:12px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    main { padding: 18px; max-width: 1200px; margin: 0 auto; display: grid; gap: 18px; }
    .row { display:grid; grid-template-columns: 1.2fr .8fr; gap:18px; }
    @media (max-width: 900px){ .row{ grid-template-columns:1fr; } }
    .card { background: var(--card); border:1px solid var(--border); border-radius:16px; padding:16px; }
    .title { font-weight:700; margin:0 0 8px; font-size:18px; }
    .muted { color: var(--muted); font-size:13px; }
    .rule { font-size:16px; margin:6px 0 10px; }
    .counts { display:flex; gap:12px; flex-wrap:wrap; }
    .pill { border:1px solid #2a2a40; padding:6px 10px; border-radius:999px; font-size:12px; }
    .pill.ok { border-color:#2c4632; color: var(--ok);}
    .pill.bad { border-color:#51303a; color: var(--bad);}
    .grid { display:grid; gap:12px; grid-template-columns: repeat(3, 1fr); }
    @media (max-width: 900px){ .grid{ grid-template-columns:1fr; } }
    .group h3 { margin:0 0 8px; font-size:16px; }
    .cols { display:grid; gap:12px; grid-template-columns: 1fr 1fr 1fr; }
    @media (max-width: 800px){ .cols{ grid-template-columns:1fr; } }
    .subhead { color: var(--muted); font-size:12px; margin-bottom:6px; }
    ul { list-style:none; padding:0; margin:0; display:flex; flex-direction:column; gap:6px; }
    li {
      background:#11111a; border:1px solid #1f1f30; padding:6px 8px; border-radius:10px;
      font-size:13px; display:flex; align-items:center; justify-content:space-between;
    }
    .banned { color: var(--bad); text-decoration: line-through; opacity:.95; border-color:#3a1f26; background:#130d10; }
    .id { color:#7f7fa0; font-size:11px; }
    .small { font-size:12px; }
    .status { min-height: 18px; }
    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background:#0f0f17; border:1px solid #29293d; border-radius:6px; padding:2px 6px; font-size:11px;
    }
  </style>
</head>
<body>
  <header>
    <h1>THE FINALS — Rule-Based Equipment Randomizer</h1>
    <div class="actions">
      <button id="newRuleBtn">New Balanced Rule</button>
      <button id="resetCacheBtn" class="secondary">Reset Cache</button>
      <div class="share" title="Share this exact rule with friends">
        <input id="shareUrl" readonly aria-label="Permalink for this rule" />
        <button id="copyLinkBtn" title="Copy link">Copy Link</button>
      </div>
    </div>
  </header>

  <main>
    <div class="row">
      <section class="card">
        <div class="title">Current Rule</div>
        <div id="ruleText" class="rule muted">Loading data…</div>
        <div class="counts">
          <span id="countAllowed" class="pill">Allowed: –</span>
          <span id="countBanned" class="pill">Banned: –</span>
          <span id="cacheInfo" class="pill">Seen rules: –</span>
        </div>
        <div class="muted small" style="margin-top:8px;">
          Constraints: <b>Allowed ≥ 15</b>, <b>Banned ≥ 25</b>, <b>≥1 weapon allowed</b>. No per-class minimums.
        </div>
        <div id="status" class="status small" aria-live="polite"></div>
      </section>

      <section class="card">
        <div class="title">How to use</div>
        <p class="muted small">
          The rule is designed to be instant to evaluate (letters, ≤2-letter sets, starts/ends, digits, symbols, bigrams, or simple AND combos).
          Click <span class="kbd">New Balanced Rule</span> for a fresh configuration. Use <span class="kbd">Copy Link</span> to share the exact same rule.
        </p>
      </section>
    </div>

    <section class="card">
      <div class="title">Equipment by Class & Category</div>
      <div id="byClass" class="grid"></div>
    </section>
  </main>

  <script>
    // ----------------------------
    // Configuration
    // ----------------------------
    const DATA_URL = "https://raw.githubusercontent.com/log2bits/the-finals-randomizer/refs/heads/main/data.json";
    const USED_RULES_KEY = "tfr_used_rules_final_v1";

    const MAX_RULE_ATTEMPTS = 2000;
    const MIN_ALLOWED = 15;
    const MIN_BANNED  = 25;
    const REQUIRE_AT_LEAST_ONE_WEAPON = true;

    const SYMBOLS = ["-", "'", "/", "+", "&", ".", "_"];
    const DIGITS  = ["0","1","2","3","4","5","6","7","8","9"];

    // ----------------------------
    // Utilities
    // ----------------------------
    const rng = () => crypto.getRandomValues(new Uint32Array(1))[0] / 2**32;
    const sample = arr => arr[Math.floor(rng()*arr.length)];
    const shuffle = arr => arr.map(v=>[v, rng()]).sort((a,b)=>a[1]-b[1]).map(x=>x[0]);
    const toKey = v => typeof v === "string" ? v : JSON.stringify(v);

    function kCombinations(arr, k){
      if(k <= 0 || k > arr.length) return [];
      const res = [];
      const pick = (start, path) => {
        if(path.length === k){ res.push(path.slice()); return; }
        for(let i=start; i<arr.length; i++) pick(i+1, path.concat(arr[i]));
      };
      pick(0, []);
      return res;
    }

    function loadUsedRules(){
      try { return new Set(JSON.parse(localStorage.getItem(USED_RULES_KEY) || "[]")); }
      catch { return new Set(); }
    }
    function saveUsedRules(set){
      localStorage.setItem(USED_RULES_KEY, JSON.stringify(Array.from(set)));
    }
    function resetUsedRules(){ localStorage.removeItem(USED_RULES_KEY); }

    // ----------------------------
    // URL encoding / decoding (permalinks)
    // ----------------------------
    function encodeRuleToUrl(ruleId, params){
      const data = { id: ruleId, params };
      const encoded = encodeURIComponent(JSON.stringify(data));
      const newHash = `#rule=${encoded}`;
      if(location.hash !== newHash){
        history.replaceState(null, "", newHash);
      }
      // update share box
      document.getElementById("shareUrl").value = location.href;
    }
    function decodeRuleFromUrl(){
      if(!location.hash.startsWith("#rule=")) return null;
      try {
        const raw = decodeURIComponent(location.hash.slice(6));
        const parsed = JSON.parse(raw);
        if(parsed && typeof parsed.id === "string") return parsed;
      } catch {}
      return null;
    }

    // ----------------------------
    // Data shaping
    // ----------------------------
    async function fetchData(){
      const res = await fetch(DATA_URL, {cache:"no-store"});
      if(!res.ok) throw new Error("Failed to fetch data.json");
      return await res.json();
    }

    function flattenItems(builds){
      const out = [];
      for(const build of builds){
        const bName = build.build?.name || "Unknown";
        for(const cat of ["specializations","gadgets","weapons"]){
          for(const item of (build[cat] || [])){
            out.push({ buildName: bName, category: item.category, id: item.id, name: item.name });
          }
        }
      }
      return out;
    }

    function makeLetterStats(items){
      const counts = {};
      const total = items.length;
      const names = items.map(i=>i.name.toLowerCase());
      for (let code=97; code<=122; code++){
        const ch = String.fromCharCode(code);
        counts[ch] = names.reduce((acc, n)=> acc + (n.includes(ch) ? 1 : 0), 0);
      }
      return {counts, total};
    }

    function makeBigramStats(items){
      const total = items.length;
      const names = items.map(i=>i.name.toLowerCase());
      const bigrams = new Map();
      const seenGlobal = new Set();
      for(const n of names){
        const s = n.replace(/[^a-z]/g, " ");
        const seenLocal = new Set();
        for(let i=0;i<s.length-1;i++){
          const a=s[i], b=s[i+1];
          if(/[a-z]/.test(a) && /[a-z]/.test(b)) seenLocal.add(a+b);
        }
        for(const bg of seenLocal) seenGlobal.add(bg);
      }
      for(const bg of seenGlobal){
        let c = 0; for(const n of names) if(n.includes(bg)) c++;
        bigrams.set(bg, c);
      }
      return { counts: bigrams, total };
    }

    function pickNearHalfFrom(entries, total, mode){
      // entries: [token,count]
      const scored = entries.map(([token, c])=>{
        const allowed = (mode === "include") ? c : (total - c);
        return { token, allowed, score: Math.abs(allowed - total/2) };
      }).sort((a,b)=> a.score - b.score);
      return scored.slice(0, 40).map(s=>s.token); // generous for variety
    }

    // ----------------------------
    // Quick checks (human-fast)
    // ----------------------------
    const hasAny = (s, arr) => {
      const t = s.toLowerCase();
      return arr.some(tok => t.includes(tok.toLowerCase()));
    };
    const excludesAll = (s, arr) => !hasAny(s, arr);
    const hasSpace = s => s.includes(" ");
    const singleWord = s => !hasSpace(s.trim());
    const startsWith = (s, ch) => s.trim().toLowerCase().startsWith(ch);
    const endsWith   = (s, ch) => s.trim().toLowerCase().endsWith(ch);
    const startsWithVowel = s => /^[aeiou]/i.test(s.trim());
    const endsWithVowel   = s => /[aeiou]$/i.test(s.trim());
    const startsWithConsonant = s => /^[^aeiou\W_]/i.test(s.trim());
    const endsWithConsonant   = s => /[^aeiou\W_]$/i.test(s.trim());
    const doubleChar = s => /(.)\1/.test(s.replace(/\s+/g,""));

    function listPretty(arr){ return arr.map(x => x.length===1 ? x.toUpperCase() : x).join(", "); }

    // ----------------------------
    // Rule definitions (no word rules; letter sets ≤ 2)
    // ----------------------------
    const BASE_RULES = [
      // Single letter include/exclude
      {
        id: "include_letter",
        label: p => `ALLOWED if the name contains “${p.toUpperCase()}”.`,
        genParams: ctx => pickNearHalfFrom(Object.entries(ctx.letterStats.counts), ctx.letterStats.total, "include"),
        predicate: (name, p) => name.toLowerCase().includes(p),
      },
      {
        id: "exclude_letter",
        label: p => `ALLOWED if the name has NO “${p.toUpperCase()}”.`,
        genParams: ctx => pickNearHalfFrom(Object.entries(ctx.letterStats.counts), ctx.letterStats.total, "exclude"),
        predicate: (name, p) => !name.toLowerCase().includes(p),
      },

      // Any-of TWO letters (≤ 2 by design)
      {
        id: "include_any_two_letters",
        label: set => `ALLOWED if the name has ${set.map(x=>x.toUpperCase()).join(" or ")}.`,
        genParams: ctx => shuffle(kCombinations(Object.keys(ctx.letterStats.counts),2)).slice(0,150),
        predicate: (name, set) => hasAny(name, set),
      },
      {
        id: "exclude_any_two_letters",
        label: set => `ALLOWED if the name has NONE of ${set.map(x=>x.toUpperCase()).join(" or ")}.`,
        genParams: ctx => shuffle(kCombinations(Object.keys(ctx.letterStats.counts),2)).slice(0,150),
        predicate: (name, set) => excludesAll(name, set),
      },

      // Starts/Ends with a specific letter (+ NOT variants)
      { id:"starts_with_letter",     label: ch=>`ALLOWED if the name starts with “${ch.toUpperCase()}”.`, genParams:ctx=>Object.keys(ctx.letterStats.counts), predicate:(n,ch)=>startsWith(n,ch) },
      { id:"not_starts_with_letter", label: ch=>`ALLOWED if the name does NOT start with “${ch.toUpperCase()}”.`, genParams:ctx=>Object.keys(ctx.letterStats.counts), predicate:(n,ch)=>!startsWith(n,ch) },
      { id:"ends_with_letter",       label: ch=>`ALLOWED if the name ends with “${ch.toUpperCase()}”.`,   genParams:ctx=>Object.keys(ctx.letterStats.counts), predicate:(n,ch)=>endsWith(n,ch) },
      { id:"not_ends_with_letter",   label: ch=>`ALLOWED if the name does NOT end with “${ch.toUpperCase()}”.`,   genParams:ctx=>Object.keys(ctx.letterStats.counts), predicate:(n,ch)=>!endsWith(n,ch) },

      // Bigrams (letter pairs)
      {
        id: "include_bigram",
        label: p => `ALLOWED if the name contains the pair “${p}”.`,
        genParams: ctx => pickNearHalfFrom(Array.from(ctx.bigramStats.counts.entries()), ctx.bigramStats.total, "include"),
        predicate: (name, p) => name.toLowerCase().includes(p),
      },
      {
        id: "exclude_bigram",
        label: p => `ALLOWED if the name does NOT contain the pair “${p}”.`,
        genParams: ctx => pickNearHalfFrom(Array.from(ctx.bigramStats.counts.entries()), ctx.bigramStats.total, "exclude"),
        predicate: (name, p) => !name.toLowerCase().includes(p),
      },

      // Digits / Symbols (with 2-token subsets)
      { id:"has_any_digit", label:()=> "ALLOWED if the name has any number (0–9).", genParams:()=>[true], predicate:(n)=>/\d/.test(n) },
      {
        id:"has_digits_subset_two",
        label:set=>`ALLOWED if the name has ${set.join(" or ")}.`,
        genParams:()=> shuffle(kCombinations(DIGITS,2)).slice(0,80),
        predicate:(n,set)=> hasAny(n,set),
      },
      { id:"has_any_symbol", label:()=>`ALLOWED if the name has any of: ${SYMBOLS.join(" ")}`, genParams:()=>[true], predicate:(n)=>SYMBOLS.some(sym=>n.includes(sym)) },
      {
        id:"has_symbols_subset_two",
        label:set=>`ALLOWED if the name has ${set.join(" or ")}.`,
        genParams:()=> shuffle(kCombinations(SYMBOLS,2)).slice(0,60),
        predicate:(n,set)=> set.some(sym=>n.includes(sym)),
      },

      // Word form / simple patterns
      { id:"single_word", label:()=> "ALLOWED if the name is a single word.", genParams:()=>[true], predicate:(n)=> singleWord(n) },
      { id:"multi_word",  label:()=> "ALLOWED if the name has multiple words.", genParams:()=>[true], predicate:(n)=> hasSpace(n) },
      { id:"starts_with_vowel", label:()=> "ALLOWED if the name starts with a vowel.", genParams:()=>[true], predicate:(n)=> startsWithVowel(n) },
      { id:"ends_with_vowel",   label:()=> "ALLOWED if the name ends with a vowel.",   genParams:()=>[true], predicate:(n)=> endsWithVowel(n) },
      { id:"starts_with_consonant", label:()=> "ALLOWED if the name starts with a consonant.", genParams:()=>[true], predicate:(n)=> startsWithConsonant(n) },
      { id:"ends_with_consonant",   label:()=> "ALLOWED if the name ends with a consonant.",   genParams:()=>[true], predicate:(n)=> endsWithConsonant(n) },
      { id:"double_char", label:()=> "ALLOWED if the name has a double letter/number (ee, ll, 11).", genParams:()=>[true], predicate:(n)=> doubleChar(n) },
    ];

    // Simple AND-compound rules (easy to evaluate)
    function compoundLabel(parts){ return "ALLOWED if " + parts.join(" AND "); }
    function compoundRule(id, labelBuilder, paramGen, predicate){ return { id, label: labelBuilder, genParams: paramGen, predicate }; }

    function buildCompoundRules(ctx){
      const letters = Object.keys(ctx.letterStats.counts);
      const topBigrams = pickNearHalfFrom(Array.from(ctx.bigramStats.counts.entries()), ctx.bigramStats.total, "include").slice(0, 28);

      const rules = [];

      // Starts with vowel AND has a hyphen
      rules.push(compoundRule(
        "starts_vowel_and_hyphen",
        () => compoundLabel(["the name starts with a vowel","it has a hyphen"]),
        () => [true],
        (name) => startsWithVowel(name) && name.includes("-")
      ));

      // Single word AND has digits pair (e.g., "1 or 2")
      const digitPairs = kCombinations(DIGITS.slice(0,4), 2); // 0–3 pairs
      rules.push(compoundRule(
        "singleword_and_digits_pair",
        p => compoundLabel(["the name is a single word", `it has ${p.join(" or ")}`]),
        () => digitPairs,
        (name, p) => singleWord(name) && hasAny(name, p)
      ));

      // Not starting with letter X AND ends with letter Y
      rules.push(compoundRule(
        "not_starts_X_ends_Y",
        p => compoundLabel([`it does NOT start with “${p.a.toUpperCase()}”`, `it ends with “${p.b.toUpperCase()}”`]),
        () => shuffle(kCombinations(letters,2)).slice(0,80).map(([a,b]) => ({a,b})),
        (name, p) => !startsWith(name, p.a) && endsWith(name, p.b)
      ));

      // Multi-word AND contains bigram “xy”
      rules.push(compoundRule(
        "multiword_and_bigram",
        p => compoundLabel(["the name has multiple words", `it contains “${p.bg}”`]),
        () => topBigrams.map(bg => ({bg})),
        (name, p) => hasSpace(name) && name.toLowerCase().includes(p.bg)
      ));

      // No symbol pair AND ends with vowel
      const symPairs = kCombinations(SYMBOLS,2);
      rules.push(compoundRule(
        "no_syms_and_ends_vowel",
        p => compoundLabel([`it has NONE of ${p.syms.join(" or ")}`, "it ends with a vowel"]),
        () => shuffle(symPairs).slice(0,60).map(syms => ({syms})),
        (name, p) => p.syms.every(s => !name.includes(s)) && endsWithVowel(name)
      ));

      return rules;
    }

    // ----------------------------
    // Rule engine / constraints
    // ----------------------------
    function ruleKey(ruleId, params){
      const normalized = Array.isArray(params) ? [...params].sort()
        : (typeof params === "object" && params ? Object.keys(params).sort().reduce((o,k)=> (o[k]=params[k], o), {}) : params);
      return `${ruleId}::${toKey(normalized)}`;
    }

    function partition(items, predicate, params){
      const allowed=[], banned=[];
      for(const it of items){
        (predicate(it.name, params) ? allowed : banned).push(it);
      }
      return {allowed, banned};
    }

    function meetsGlobalBalance(allowedCount, bannedCount){
      return allowedCount >= MIN_ALLOWED && bannedCount >= MIN_BANNED;
    }

    function atLeastOneWeaponAllowed(allowedItems){
      if(!REQUIRE_AT_LEAST_ONE_WEAPON) return true;
      return allowedItems.some(it => it.category === "weapon");
    }

    // ----------------------------
    // Rendering
    // ----------------------------
    function renderByClass(allItems, allowedSet){
      const container = document.getElementById("byClass");
      container.innerHTML = "";
      // Build map of all items by class & category
      const grouped = {};
      for(const it of allItems){
        grouped[it.buildName] ??= { specialization:[], gadget:[], weapon:[] };
        grouped[it.buildName][it.category].push(it);
      }
      for(const [buildName, cats] of Object.entries(grouped)){
        const groupDiv = document.createElement("div"); groupDiv.className = "group";
        const cols = document.createElement("div"); cols.className = "cols";
        groupDiv.innerHTML = `<h3>${buildName}</h3>`;
        for(const cat of ["specialization","gadget","weapon"]){
          const block = document.createElement("div");
          block.innerHTML = `<div class="subhead">${cat[0].toUpperCase()+cat.slice(1)}</div>`;
          const ul = document.createElement("ul");
          for(const item of (cats[cat] || [])){
            const li = document.createElement("li");
            const isAllowed = allowedSet.has(item.id);
            if(!isAllowed) li.classList.add("banned");
            li.innerHTML = `<span>${item.name}</span><span class="id">#${item.id}</span>`;
            ul.appendChild(li);
          }
          block.appendChild(ul);
          cols.appendChild(block);
        }
        groupDiv.appendChild(cols);
        container.appendChild(groupDiv);
      }
    }

    function showCounts(a, b){
      const A = document.getElementById("countAllowed");
      const B = document.getElementById("countBanned");
      A.textContent = `Allowed: ${a}`;
      B.textContent = `Banned: ${b}`;
      A.className = `pill ${a>=MIN_ALLOWED ? "ok":"bad"}`;
      B.className = `pill ${b>=MIN_BANNED ? "ok":"bad"}`;
    }

    function setStatus(msg, type=""){
      const el = document.getElementById("status");
      el.textContent = msg || "";
      el.style.color = type==="error" ? "var(--bad)" : (type==="ok" ? "var(--ok)" : "var(--muted)");
    }

    function renderRule(chosen, params, part, allBuilds){
      // Update rule text, counts, list, URL, share box
      document.getElementById("ruleText").textContent = chosen.label(params);
      const allowedSet = new Set(part.allowed.map(i=>i.id));
      showCounts(part.allowed.length, part.banned.length);
      renderByClass(flattenItems(allBuilds), allowedSet);
      encodeRuleToUrl(chosen.id, params);
      setStatus("Ready. Share the link to sync this exact rule.", "ok");
    }

    // ----------------------------
    // Generation & shared rule loading
    // ----------------------------
    async function generateBalancedRule(builds){
      const items = flattenItems(builds);
      const letterStats = makeLetterStats(items);
      const bigramStats = makeBigramStats(items);
      const ctx = { items, letterStats, bigramStats };

      const RULES = [...BASE_RULES, ...buildCompoundRules(ctx)];
      const used = loadUsedRules();
      const ruleOrder = shuffle([...RULES]);

      for(let attempts = 0; attempts < MAX_RULE_ATTEMPTS; attempts++){
        const rule = sample(ruleOrder);
        const paramsList = shuffle(rule.genParams(ctx));
        for(const p of paramsList){
          const key = ruleKey(rule.id, p);
          if(used.has(key)) continue;

          const res = partition(items, rule.predicate, p);
          if(!meetsGlobalBalance(res.allowed.length, res.banned.length)) continue;
          if(REQUIRE_AT_LEAST_ONE_WEAPON && !atLeastOneWeaponAllowed(res.allowed)) continue;

          // store uniqueness and return
          used.add(key); saveUsedRules(used);
          return { rule, params: p, part: res };
        }
      }
      return null; // none found
    }

    async function generateFromSharedRule(builds, ruleData){
      const items = flattenItems(builds);
      const letterStats = makeLetterStats(items);
      const bigramStats = makeBigramStats(items);
      const ctx = { items, letterStats, bigramStats };
      const RULES = [...BASE_RULES, ...buildCompoundRules(ctx)];
      const rule = RULES.find(r => r.id === ruleData.id);
      if(!rule) return null;
      const res = partition(items, rule.predicate, ruleData.params);
      if(!meetsGlobalBalance(res.allowed.length, res.banned.length)) return null;
      if(REQUIRE_AT_LEAST_ONE_WEAPON && !atLeastOneWeaponAllowed(res.allowed)) return null;
      return { rule, params: ruleData.params, part: res };
    }

    // ----------------------------
    // UI wiring
    // ----------------------------
    const newRuleBtn = document.getElementById("newRuleBtn");
    const resetCacheBtn = document.getElementById("resetCacheBtn");
    const copyLinkBtn = document.getElementById("copyLinkBtn");
    const shareInput = document.getElementById("shareUrl");
    const cacheInfo = document.getElementById("cacheInfo");

    function setBusy(b){
      newRuleBtn.disabled = b;
      resetCacheBtn.disabled = b;
      copyLinkBtn.disabled = b;
    }

    document.getElementById("copyLinkBtn").addEventListener("click", async ()=>{
      try{
        shareInput.select();
        await navigator.clipboard.writeText(shareInput.value);
        setStatus("Copied link to clipboard.", "ok");
      }catch{
        setStatus("Could not copy. Select and copy manually.", "error");
      }
    });

    resetCacheBtn.addEventListener("click", ()=>{
      resetUsedRules();
      cacheInfo.textContent = "Seen rules: 0";
      setStatus("Rule cache cleared. Generate again for fresh options.", "ok");
    });

    newRuleBtn.addEventListener("click", async ()=>{
      try{
        setBusy(true);
        setStatus("Searching for a fresh, balanced rule…");
        const builds = window.__DATA_BUILDS || [];
        const result = await generateBalancedRule(builds);
        if(!result){
          setStatus("No new balanced rule found right now. Try Reset Cache or click again.", "error");
          return;
        }
        cacheInfo.textContent = `Seen rules: ${loadUsedRules().size}`;
        renderRule(result.rule, result.params, result.part, builds);
      }catch(err){
        setStatus(`Error: ${err.message}`, "error");
      }finally{
        setBusy(false);
      }
    });

    // ----------------------------
    // Init
    // ----------------------------
    (async function init(){
      try{
        setBusy(true);
        shareInput.value = location.href;
        const data = await fetchData();
        window.__DATA_BUILDS = Array.isArray(data) ? data : [];
        cacheInfo.textContent = `Seen rules: ${loadUsedRules().size}`;

        const shared = decodeRuleFromUrl();
        if(shared){
          setStatus("Loading shared rule…");
          const forced = await generateFromSharedRule(window.__DATA_BUILDS, shared);
          if(forced){
            renderRule(forced.rule, forced.params, forced.part, window.__DATA_BUILDS);
            setBusy(false);
            return;
          } else {
            setStatus("Shared rule not valid with current data. Generating a fresh one…");
          }
        }

        const result = await generateBalancedRule(window.__DATA_BUILDS);
        if(!result){
          setStatus("Couldn’t find a balanced rule. Try Reset Cache and click again.", "error");
          return;
        }
        renderRule(result.rule, result.params, result.part, window.__DATA_BUILDS);
        cacheInfo.textContent = `Seen rules: ${loadUsedRules().size}`;
      }catch(err){
        setStatus(`Failed to load data: ${err.message}`, "error");
      }finally{
        setBusy(false);
      }
    })();
  </script>
</body>
</html>
