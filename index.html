<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>The Finals Equipment Randomizer (Rule-Based)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --bg:#0b0b10; --card:#141420; --muted:#8b8ba0; --text:#e8e8ee; --accent:#7aa2f7; --ok:#7ce38b; --bad:#f7768e; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji"; background: var(--bg); color: var(--text);}
    header { padding: 16px 20px; display:flex; gap:12px; align-items:center; justify-content:space-between; border-bottom:1px solid #1e1e2a;}
    h1 { margin:0; font-size: clamp(18px, 3vw, 22px); letter-spacing: .2px; }
    .actions { display:flex; gap:10px; flex-wrap:wrap; }
    button { background: var(--card); border:1px solid #24243a; color: var(--text); padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600; transition: .15s transform ease, .15s background ease; }
    button:hover { transform: translateY(-1px); background:#1a1a2b; }
    button.secondary { background:transparent; }
    main { padding: 18px; max-width: 1200px; margin: 0 auto; display: grid; gap: 18px; }
    .row { display:grid; grid-template-columns: 1.2fr .8fr; gap:18px; }
    @media (max-width: 900px){ .row{ grid-template-columns:1fr; } }
    .card { background: var(--card); border:1px solid #1d1d2b; border-radius:16px; padding:16px; }
    .title { font-weight:700; margin: 0 0 8px; font-size: 18px; }
    .muted { color: var(--muted); font-size: 13px; }
    .rule { font-size: 16px; margin: 6px 0 10px; }
    .counts { display:flex; gap:12px; flex-wrap:wrap; }
    .pill { border:1px solid #2a2a40; padding:6px 10px; border-radius:999px; font-size: 12px; }
    .pill.ok { border-color:#2c4632; color: var(--ok);}
    .pill.bad { border-color:#51303a; color: var(--bad);}
    .grid { display:grid; gap:12px; grid-template-columns: repeat(3, 1fr); }
    @media (max-width: 900px){ .grid{ grid-template-columns:1fr; } }
    .group h3 { margin:0 0 6px; font-size: 15px; }
    ul { list-style:none; padding:0; margin:0; display:flex; flex-wrap:wrap; gap:6px; }
    li { background:#11111a; border:1px solid #1f1f30; padding:6px 8px; border-radius:10px; font-size: 13px; }
    .legend { display:flex; gap:10px; flex-wrap:wrap; }
    .legend .tag { font-size:12px; border:1px dashed #2a2a40; padding:4px 8px; border-radius:999px;}
    .small { font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .footer { color: var(--muted); font-size: 12px; text-align:center; padding: 12px 0 20px; }
    .error { color: var(--bad); }
    .success { color: var(--ok); }
    details { border:1px solid #23233a; border-radius:12px; padding:8px 12px; }
    details[open] { background:#101019; }
    summary { cursor:pointer; font-weight:600; margin:6px 0; }
    .lists { display:grid; gap:12px; grid-template-columns: 1fr 1fr; }
    @media (max-width: 700px){ .lists{ grid-template-columns:1fr; } }
    .nowrap { white-space: nowrap; }
  </style>
</head>
<body>
  <header>
    <h1>THE FINALS – Rule-Based Equipment Randomizer</h1>
    <div class="actions">
      <button id="newRuleBtn">Generate New Rule</button>
      <button id="resetCacheBtn" class="secondary">Reset Rules Cache</button>
    </div>
  </header>

  <main>
    <div class="row">
      <section class="card">
        <div class="title">Current Rule</div>
        <div id="ruleText" class="rule muted">Loading data…</div>
        <div class="counts">
          <span id="countAllowed" class="pill">Allowed: –</span>
          <span id="countBanned" class="pill">Banned: –</span>
          <span id="cacheInfo" class="pill">Seen rules: –</span>
        </div>
        <div class="legend" style="margin-top:10px">
          <span class="tag">Guarantees per class: <span class="nowrap mono">≥1</span> spec, <span class="nowrap mono">≥3</span> gadgets, <span class="nowrap mono">≥1</span> weapon</span>
          <span class="tag">Also: at least <span class="mono">25</span> allowed & <span class="mono">25</span> banned overall</span>
        </div>
        <div id="status" class="small" style="margin-top:8px;"></div>
      </section>

      <section class="card">
        <div class="title">Controls</div>
        <p class="muted small">Rules are intentionally simple for humans to apply quickly (letters, digits, hyphens, spaces). The generator will try multiple rules until it finds a balanced one you haven’t used yet.</p>
        <details>
          <summary>How rules work (dev notes)</summary>
          <ul class="small">
            <li>Modular: add rules in <span class="mono">RULES</span>.</li>
            <li>Each rule defines <span class="mono">genParams(ctx)</span> and <span class="mono">predicate(name, params)</span>.</li>
            <li>We compute letter/symbol frequencies and sample parameters that tend to split near 50/50.</li>
            <li>Uniqueness via <span class="mono">localStorage["tfr_used_rules_v1"]</span>.</li>
          </ul>
        </details>
      </section>
    </div>

    <section class="card">
      <div class="title">Allowed Equipment (by Class & Category)</div>
      <div id="allowedWrap" class="grid"></div>
    </section>

    <section class="card">
      <div class="title">Banned (for reference)</div>
      <div id="bannedWrap" class="lists"></div>
      <p class="muted small" style="margin-top:10px">You rarely need to read this—players only need the rule & allowed list.</p>
    </section>
  </main>

  <div class="footer">Made for quick, unique lobbies. Add your own rules in the source. Data loads from your GitHub JSON.</div>

  <script>
    // ----------------------------
    // Utilities
    // ----------------------------
    const USED_RULES_KEY = "tfr_used_rules_v1";
    const MAX_RULE_ATTEMPTS = 300;
    const MIN_ALLOWED = 25, MIN_BANNED = 25;
    const MIN_PER_CLASS = { specialization: 1, gadget: 3, weapon: 1 };

    const sample = arr => arr[Math.floor(crypto.getRandomValues(new Uint32Array(1))[0] / 2**32 * arr.length)];
    const shuffle = arr => arr.map(v=>[v, crypto.getRandomValues(new Uint32Array(1))[0]]).sort((a,b)=>a[1]-b[1]).map(x=>x[0]);

    function loadUsedRules(){
      try { return new Set(JSON.parse(localStorage.getItem(USED_RULES_KEY) || "[]")); }
      catch { return new Set(); }
    }
    function saveUsedRules(set){
      localStorage.setItem(USED_RULES_KEY, JSON.stringify(Array.from(set)));
    }
    function resetUsedRules(){
      localStorage.removeItem(USED_RULES_KEY);
    }

    // ----------------------------
    // Fetch data
    // ----------------------------
    const DATA_URL = "https://raw.githubusercontent.com/log2bits/the-finals-randomizer/refs/heads/main/data.json";

    async function fetchData(){
      // Try remote first; fall back to embedded minimal error if needed
      const res = await fetch(DATA_URL, {cache:"no-store"});
      if(!res.ok) throw new Error("Failed to fetch data.json from GitHub");
      return await res.json();
    }

    // ----------------------------
    // Data helpers
    // ----------------------------
    function flattenItems(builds){
      // returns array of {buildName, category, id, name}
      const out = [];
      for(const build of builds){
        const bName = build.build?.name || "Unknown";
        for(const cat of ["specializations","gadgets","weapons"]){
          for(const item of (build[cat] || [])){
            out.push({ buildName: bName, category: item.category, id: item.id, name: item.name });
          }
        }
      }
      return out;
    }

    function byBuildAndCategory(items){
      const map = {}; // map[buildName][category] = [items]
      for(const it of items){
        map[it.buildName] ??= {};
        map[it.buildName][it.category] ??= [];
        map[it.buildName][it.category].push(it);
      }
      return map;
    }

    // ----------------------------
    // Rule engine (modular)
    // Each rule has:
    //   id: string
    //   label(params): string   // human readable description
    //   genParams(ctx): array   // candidate parameter values
    //   predicate(name, params): boolean
    // ----------------------------

    function makeLetterStats(items){
      // Count presence of each letter a-z in names
      const counts = {};
      const total = items.length;
      const names = items.map(i=>i.name.toLowerCase());
      for (let code=97; code<=122; code++){
        const ch = String.fromCharCode(code);
        counts[ch] = names.reduce((acc, n)=> acc + (n.includes(ch) ? 1 : 0), 0);
      }
      return {counts, total};
    }

    function hasDigit(s){ return /\d/.test(s); }
    function hasHyphen(s){ return s.includes("-"); }
    function hasApostrophe(s){ return s.includes("'"); }
    function hasSpace(s){ return s.includes(" "); }

    // Helper to bias letter choices toward ~half split
    function pickLettersNearHalf(letterStats, mode){ // mode: "include" or "exclude"
      const {counts, total} = letterStats;
      const targets = [];
      for(const [ch, c] of Object.entries(counts)){
        const allowedIfInclude = c;
        const allowedIfExclude = total - c;
        const allowed = (mode === "include") ? allowedIfInclude : allowedIfExclude;
        const score = Math.abs(allowed - total/2); // closeness to half
        targets.push({ch, allowed, score});
      }
      // Sort by closeness to half and take top 10 as candidates
      targets.sort((a,b)=> a.score - b.score);
      return targets.slice(0, 10).map(t=>t.ch);
    }

    const RULES = [
      {
        id: "include_letter",
        label: p => `ALLOWED if the name has the letter “${p}” (case-insensitive).`,
        genParams: ctx => pickLettersNearHalf(ctx.letterStats, "include"),
        predicate: (name, p) => name.toLowerCase().includes(p),
      },
      {
        id: "exclude_letter",
        label: p => `ALLOWED if the name has NO letter “${p}”.`,
        genParams: ctx => pickLettersNearHalf(ctx.letterStats, "exclude"),
        predicate: (name, p) => !name.toLowerCase().includes(p),
      },
      {
        id: "has_digit",
        label: () => "ALLOWED if the name has any number (0–9).",
        genParams: () => [true],
        predicate: (name) => hasDigit(name),
      },
      {
        id: "has_hyphen",
        label: () => "ALLOWED if the name has a hyphen (–).",
        genParams: () => [true],
        predicate: (name) => hasHyphen(name),
      },
      {
        id: "has_apostrophe",
        label: () => "ALLOWED if the name has an apostrophe (’).",
        genParams: () => [true],
        predicate: (name) => hasApostrophe(name),
      },
      {
        id: "has_space",
        label: () => "ALLOWED if the name contains a space.",
        genParams: () => [true],
        predicate: (name) => hasSpace(name),
      },
      // Add new rules here. Keep them human-easy and quick to verify.
    ];

    function ruleKey(ruleId, params){
      return `${ruleId}::${JSON.stringify(params)}`;
    }

    // ----------------------------
    // Selection / constraints
    // ----------------------------
    function partition(items, predicate, params){
      const allowed=[], banned=[];
      for(const it of items){
        (predicate(it.name, params) ? allowed : banned).push(it);
      }
      return {allowed, banned};
    }

    function meetsGlobalBalance(allowedCount, bannedCount){
      return allowedCount >= MIN_ALLOWED && bannedCount >= MIN_BANNED;
    }

    function meetsPerClassMinimums(allowedItems){
      // Build -> category -> count
      const map = byBuildAndCategory(allowedItems);
      const builds = Object.keys(map);
      // If some classes are missing entirely in data, treat them as failing unless their categories don't exist
      for(const buildName of builds){
        const cats = map[buildName];
        for (const [cat, min] of Object.entries(MIN_PER_CLASS)){
          const have = (cats[cat]?.length || 0);
          if (have < min) return false;
        }
      }
      // Also ensure any build present in data gets minimums; if some build is missing (unexpected), verify it from data shape
      // To be thorough, check globally present builds by inspecting source data:
      if(window.__ALL_BUILD_NAMES){
        for(const b of window.__ALL_BUILD_NAMES){
          if(!map[b]) return false; // must have at least something allowed in that build
          for(const [cat, min] of Object.entries(MIN_PER_CLASS)){
            if((map[b][cat]?.length || 0) < min) return false;
          }
        }
      }
      return true;
    }

    function renderLists(allowed, banned){
      // Allowed grouped by Build then Category
      const byBuild = {};
      for(const it of allowed){
        byBuild[it.buildName] ??= { specialization:[], gadget:[], weapon:[] };
        byBuild[it.buildName][it.category].push(it);
      }
      const allowedWrap = document.getElementById("allowedWrap");
      allowedWrap.innerHTML = "";
      for(const buildName of Object.keys(byBuild)){
        const sect = document.createElement("div"); sect.className="group";
        sect.innerHTML = `<h3>${buildName}</h3>
          <div class="lists">
            <div><div class="muted small">Specializations</div><ul>${byBuild[buildName].specialization.map(i=>`<li title="${i.id}">${i.name}</li>`).join("")}</ul></div>
            <div><div class="muted small">Gadgets</div><ul>${byBuild[buildName].gadget.map(i=>`<li title="${i.id}">${i.name}</li>`).join("")}</ul></div>
            <div><div class="muted small">Weapons</div><ul>${byBuild[buildName].weapon.map(i=>`<li title="${i.id}">${i.name}</li>`).join("")}</ul></div>
          </div>`;
        allowedWrap.appendChild(sect);
      }

      // Banned flattened, split in two columns for readability
      const bannedWrap = document.getElementById("bannedWrap");
      const half = Math.ceil(banned.length/2);
      const colA = banned.slice(0, half), colB = banned.slice(half);
      bannedWrap.innerHTML = `
        <div>
          <div class="muted small">Banned (A)</div>
          <ul>${colA.map(i=>`<li title="${i.buildName} / ${i.category}">${i.name}</li>`).join("")}</ul>
        </div>
        <div>
          <div class="muted small">Banned (B)</div>
          <ul>${colB.map(i=>`<li title="${i.buildName} / ${i.category}">${i.name}</li>`).join("")}</ul>
        </div>
      `;
    }

    function showCounts(allowedCount, bannedCount, okPerClass){
      const a = document.getElementById("countAllowed");
      const b = document.getElementById("countBanned");
      a.textContent = `Allowed: ${allowedCount}`;
      b.textContent = `Banned: ${bannedCount}`;
      a.className = `pill ${allowedCount>=MIN_ALLOWED ? "ok":"bad"}`;
      b.className = `pill ${bannedCount>=MIN_BANNED ? "ok":"bad"}`;
      const status = document.getElementById("status");
      status.innerHTML = okPerClass
        ? `<span class="success">All per-class minimums satisfied.</span>`
        : `<span class="error">Per-class minimums NOT satisfied.</span>`;
    }

    async function generateRuleAndRender(builds){
      const items = flattenItems(builds);
      const allBuildNames = builds.map(b=>b.build?.name).filter(Boolean);
      window.__ALL_BUILD_NAMES = allBuildNames;

      const ctx = {
        letterStats: makeLetterStats(items),
        items
      };

      const used = loadUsedRules();
      const ruleOrder = shuffle([...RULES]); // randomize rule order per attempt batch
      let chosen = null, chosenParams = null, part = null;

      outer:
      for(let attempts = 0; attempts < MAX_RULE_ATTEMPTS; attempts++){
        const rule = sample(ruleOrder);
        const paramsList = shuffle(rule.genParams(ctx));
        for(const p of paramsList){
          const key = ruleKey(rule.id, p);
          if(used.has(key)) continue;
          const res = partition(items, rule.predicate, p);
          const okGlobal = meetsGlobalBalance(res.allowed.length, res.banned.length);
          if(!okGlobal) continue;

          const okPerClass = meetsPerClassMinimums(res.allowed);
          if(!okPerClass) continue;

          chosen = rule; chosenParams = p; part = res;
          used.add(key);
          saveUsedRules(used);
          break outer;
        }
      }

      const ruleText = document.getElementById("ruleText");
      const cacheInfo = document.getElementById("cacheInfo");

      cacheInfo.textContent = `Seen rules: ${loadUsedRules().size}`;

      if(!chosen){
        ruleText.innerHTML = `<span class="error">Couldn’t find a new balanced rule. Try “Reset Rules Cache” and generate again.</span>`;
        showCounts(0,0,false);
        renderLists([],[]);
        return;
      }

      ruleText.textContent = chosen.label(chosenParams);
      showCounts(part.allowed.length, part.banned.length, true);
      renderLists(part.allowed, part.banned);
    }

    // ----------------------------
    // Wire up UI
    // ----------------------------
    document.getElementById("newRuleBtn").addEventListener("click", async ()=>{
      try{
        document.getElementById("ruleText").textContent = "Thinking up a balanced rule…";
        const builds = window.__DATA_BUILDS || [];
        await generateRuleAndRender(builds);
      }catch(err){
        document.getElementById("ruleText").innerHTML = `<span class="error">Error: ${err.message}</span>`;
      }
    });

    document.getElementById("resetCacheBtn").addEventListener("click", ()=>{
      resetUsedRules();
      document.getElementById("cacheInfo").textContent = "Seen rules: 0";
    });

    // ----------------------------
    // Init
    // ----------------------------
    (async function init(){
      try{
        const data = await fetchData();
        window.__DATA_BUILDS = Array.isArray(data) ? data : [];
        document.getElementById("ruleText").textContent = "Generating...";
        await generateRuleAndRender(window.__DATA_BUILDS);
      }catch(err){
        document.getElementById("ruleText").innerHTML = `<span class="error">Failed to load data: ${err.message}</span>`;
      }
    })();
  </script>
</body>
</html>
