<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>The Finals Equipment Randomizer — Fast Rules</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --bg:#0b0b10; --card:#141420; --muted:#8b8ba0; --text:#e8e8ee; --ok:#7ce38b; --bad:#f7768e; --border:#1d1d2b; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Inter, Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--text);}
    header { padding: 16px 20px; display:flex; gap:12px; align-items:center; justify-content:space-between; border-bottom:1px solid #1e1e2a;}
    h1 { margin:0; font-size: clamp(18px, 3vw, 22px); letter-spacing: .2px; }
    .actions { display:flex; gap:10px; flex-wrap:wrap; }
    button { background: var(--card); border:1px solid #24243a; color: var(--text); padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600; transition: .15s transform ease, .15s background ease; }
    button:hover { transform: translateY(-1px); background:#1a1a2b; }
    button.secondary { background:transparent; }
    main { padding: 18px; max-width: 1200px; margin: 0 auto; display: grid; gap: 18px; }
    .row { display:grid; grid-template-columns: 1.2fr .8fr; gap:18px; }
    @media (max-width: 900px){ .row{ grid-template-columns:1fr; } }
    .card { background: var(--card); border:1px solid var(--border); border-radius:16px; padding:16px; }
    .title { font-weight:700; margin: 0 0 8px; font-size: 18px; }
    .muted { color: var(--muted); font-size: 13px; }
    .rule { font-size: 16px; margin: 6px 0 10px; }
    .counts { display:flex; gap:12px; flex-wrap:wrap; }
    .pill { border:1px solid #2a2a40; padding:6px 10px; border-radius:999px; font-size: 12px; }
    .pill.ok { border-color:#2c4632; color: var(--ok);}
    .pill.bad { border-color:#51303a; color: var(--bad);}
    .grid { display:grid; gap:12px; grid-template-columns: repeat(3, 1fr); }
    @media (max-width: 900px){ .grid{ grid-template-columns:1fr; } }
    .group h3 { margin:0 0 8px; font-size: 16px; }
    .cols { display:grid; gap:12px; grid-template-columns: 1fr 1fr 1fr; }
    @media (max-width: 800px){ .cols{ grid-template-columns:1fr; } }
    .subhead { color: var(--muted); font-size:12px; margin-bottom:6px; }
    ul { list-style:none; padding:0; margin:0; display:flex; flex-direction:column; gap:6px; }
    li { background:#11111a; border:1px solid #1f1f30; padding:6px 8px; border-radius:10px; font-size: 13px; display:flex; align-items:center; justify-content:space-between; }
    .banned { color: var(--bad); text-decoration: line-through; opacity:.95; border-color:#3a1f26; background:#130d10; }
    .id { color:#7f7fa0; font-size:11px; }
    .small { font-size: 12px; }
  </style>
</head>
<body>
  <header>
    <h1>THE FINALS — Rule-Based Equipment Randomizer</h1>
    <div class="actions">
      <button id="newRuleBtn">Generate New Rule</button>
      <button id="resetCacheBtn" class="secondary">Reset Rules Cache</button>
    </div>
  </header>

  <main>
    <div class="row">
      <section class="card">
        <div class="title">Current Rule</div>
        <div id="ruleText" class="rule muted">Loading data…</div>
        <div class="counts">
          <span id="countAllowed" class="pill">Allowed: –</span>
          <span id="countBanned" class="pill">Banned: –</span>
          <span id="cacheInfo" class="pill">Seen rules: –</span>
        </div>
        <div class="muted small" style="margin-top:8px;">
          Constraints: <b>Allowed ≥ 15</b>, <b>Banned ≥ 25</b>, <b>≥1 weapon allowed overall</b>.
        </div>
      </section>

      <section class="card">
        <div class="title">Notes</div>
        <p class="muted small">
          Rules are human-fast: single letters, ≤2-letter sets, starts/ends, digits, symbols, bigrams, plus a few simple AND-combos (no word rules). Unused rules are cached in your browser and skipped automatically.
        </p>
      </section>
    </div>

    <section class="card">
      <div class="title">Equipment by Class & Category</div>
      <div id="byClass" class="grid"></div>
    </section>
  </main>

  <script>
    // ----------------------------
    // Config
    // ----------------------------
    const DATA_URL = "https://raw.githubusercontent.com/log2bits/the-finals-randomizer/refs/heads/main/data.json";
    const USED_RULES_KEY = "tfr_used_rules_v4";

    const MAX_RULE_ATTEMPTS = 1500;
    const MIN_ALLOWED = 15;
    const MIN_BANNED  = 25;
    const REQUIRE_AT_LEAST_ONE_WEAPON = true;

    const SYMBOLS = ["-", "'", "/", "+", "&", ".", "_"];
    const DIGITS  = ["0","1","2","3","4","5","6","7","8","9"];

    // ----------------------------
    // Utils
    // ----------------------------
    const rng = () => crypto.getRandomValues(new Uint32Array(1))[0] / 2**32;
    const sample = arr => arr[Math.floor(rng()*arr.length)];
    const shuffle = arr => arr.map(v=>[v, rng()]).sort((a,b)=>a[1]-b[1]).map(x=>x[0]);
    const unique = arr => Array.from(new Set(arr));
    const toKey = v => typeof v === "string" ? v : JSON.stringify(v);

    function kCombinations(arr, k){
      if(k <= 0 || k > arr.length) return [];
      const res = [];
      const pick = (start, path) => {
        if(path.length === k){ res.push(path.slice()); return; }
        for(let i=start; i<arr.length; i++) pick(i+1, path.concat(arr[i]));
      };
      pick(0, []);
      return res;
    }

    function loadUsedRules(){ try { return new Set(JSON.parse(localStorage.getItem(USED_RULES_KEY) || "[]")); } catch { return new Set(); } }
    function saveUsedRules(set){ localStorage.setItem(USED_RULES_KEY, JSON.stringify(Array.from(set))); }
    function resetUsedRules(){ localStorage.removeItem(USED_RULES_KEY); }

    // ----------------------------
    // Fetch / shape data
    // ----------------------------
    async function fetchData(){
      const res = await fetch(DATA_URL, {cache:"no-store"});
      if(!res.ok) throw new Error("Failed to fetch data.json from GitHub");
      return await res.json();
    }

    function flattenItems(builds){
      const out = [];
      for(const build of builds){
        const bName = build.build?.name || "Unknown";
        for(const cat of ["specializations","gadgets","weapons"]){
          for(const item of (build[cat] || [])){
            out.push({ buildName: bName, category: item.category, id: item.id, name: item.name });
          }
        }
      }
      return out;
    }
    function groupByBuildAndCategory(items){
      const map = {};
      for(const it of items){
        map[it.buildName] ??= { specialization:[], gadget:[], weapon:[] };
        map[it.buildName][it.category].push(it);
      }
      return map;
    }

    // ----------------------------
    // Stats (letters & bigrams)
    // ----------------------------
    function makeLetterStats(items){
      const counts = {};
      const total = items.length;
      const names = items.map(i=>i.name.toLowerCase());
      for (let code=97; code<=122; code++){
        const ch = String.fromCharCode(code);
        counts[ch] = names.reduce((acc, n)=> acc + (n.includes(ch) ? 1 : 0), 0);
      }
      return {counts, total};
    }

    function makeBigramStats(items){
      const total = items.length;
      const names = items.map(i=>i.name.toLowerCase());
      const bigrams = new Map();
      const seenGlobal = new Set();
      for(const n of names){
        const s = n.replace(/[^a-z]/g, " ");
        const seenLocal = new Set();
        for(let i=0;i<s.length-1;i++){
          const a=s[i], b=s[i+1];
          if(/[a-z]/.test(a) && /[a-z]/.test(b)) seenLocal.add(a+b);
        }
        for(const bg of seenLocal) seenGlobal.add(bg);
      }
      for(const bg of seenGlobal){
        let c = 0; for(const n of names) if(n.includes(bg)) c++;
        bigrams.set(bg, c);
      }
      return { counts: bigrams, total };
    }

    function pickNearHalfFrom(entries, total, mode){
      // entries: [token,count]
      const scored = entries.map(([token, c])=>{
        const allowed = (mode === "include") ? c : (total - c);
        return { token, allowed, score: Math.abs(allowed - total/2) };
      }).sort((a,b)=> a.score - b.score);
      return scored.slice(0, 36).map(s=>s.token); // generous slice for variety
    }

    // ----------------------------
    // Quick checks (human-easy)
    // ----------------------------
    const hasAny = (s, arr) => {
      const t = s.toLowerCase();
      return arr.some(tok => t.includes(tok.toLowerCase()));
    };
    const excludesAll = (s, arr) => !hasAny(s, arr);
    const hasSpace = s => s.includes(" ");
    const singleWord = s => !hasSpace(s.trim());
    const startsWith = (s, ch) => s.trim().toLowerCase().startsWith(ch);
    const endsWith = (s, ch) => s.trim().toLowerCase().endsWith(ch);
    const startsWithVowel = s => /^[aeiou]/i.test(s.trim());
    const endsWithVowel = s => /[aeiou]$/i.test(s.trim());
    const startsWithConsonant = s => /^[^aeiou\W_]/i.test(s.trim());
    const endsWithConsonant = s => /[^aeiou\W_]$/i.test(s.trim());
    const doubleChar = s => /(.)\1/.test(s.replace(/\s+/g,""));

    // ----------------------------
    // RULES (no keyword rules; letter sets ≤ 2)
    // Each rule: { id, label(params), genParams(ctx), predicate(name, params) }
    // ----------------------------
    function listPretty(arr){ return arr.map(x => x.length===1 ? x.toUpperCase() : x).join(", "); }

    const BASE_RULES = [
      // Letters (single include/exclude)
      {
        id: "include_letter",
        label: p => `ALLOWED if the name contains “${p.toUpperCase()}”.`,
        genParams: ctx => pickNearHalfFrom(Object.entries(ctx.letterStats.counts), ctx.letterStats.total, "include"),
        predicate: (name, p) => name.toLowerCase().includes(p),
      },
      {
        id: "exclude_letter",
        label: p => `ALLOWED if the name has NO “${p.toUpperCase()}”.`,
        genParams: ctx => pickNearHalfFrom(Object.entries(ctx.letterStats.counts), ctx.letterStats.total, "exclude"),
        predicate: (name, p) => !name.toLowerCase().includes(p),
      },

      // Letter sets (any-of) — capped to size 2
      {
        id: "include_any_two_letters",
        label: set => `ALLOWED if the name has “${listPretty(set)}”.`,
        genParams: ctx => shuffle(kCombinations(Object.keys(ctx.letterStats.counts),2)).slice(0,120),
        predicate: (name, set) => hasAny(name, set),
      },
      {
        id: "exclude_any_two_letters",
        label: set => `ALLOWED if the name has NONE of “${listPretty(set)}”.`,
        genParams: ctx => shuffle(kCombinations(Object.keys(ctx.letterStats.counts),2)).slice(0,120),
        predicate: (name, set) => excludesAll(name, set),
      },

      // Starts / Ends with single letter (+ NOT variants)
      {
        id: "starts_with_letter",
        label: ch => `ALLOWED if the name starts with “${ch.toUpperCase()}”.`,
        genParams: ctx => Object.keys(ctx.letterStats.counts),
        predicate: (name, ch) => startsWith(name, ch),
      },
      {
        id: "not_starts_with_letter",
        label: ch => `ALLOWED if the name does NOT start with “${ch.toUpperCase()}”.`,
        genParams: ctx => Object.keys(ctx.letterStats.counts),
        predicate: (name, ch) => !startsWith(name, ch),
      },
      {
        id: "ends_with_letter",
        label: ch => `ALLOWED if the name ends with “${ch.toUpperCase()}”.`,
        genParams: ctx => Object.keys(ctx.letterStats.counts),
        predicate: (name, ch) => endsWith(name, ch),
      },
      {
        id: "not_ends_with_letter",
        label: ch => `ALLOWED if the name does NOT end with “${ch.toUpperCase()}”.`,
        genParams: ctx => Object.keys(ctx.letterStats.counts),
        predicate: (name, ch) => !endsWith(name, ch),
      },

      // Bigrams (letter pairs in sequence)
      {
        id: "include_bigram",
        label: p => `ALLOWED if the name contains the pair “${p}”.`,
        genParams: ctx => pickNearHalfFrom(Array.from(ctx.bigramStats.counts.entries()), ctx.bigramStats.total, "include"),
        predicate: (name, p) => name.toLowerCase().includes(p),
      },
      {
        id: "exclude_bigram",
        label: p => `ALLOWED if the name does NOT contain the pair “${p}”.`,
        genParams: ctx => pickNearHalfFrom(Array.from(ctx.bigramStats.counts.entries()), ctx.bigramStats.total, "exclude"),
        predicate: (name, p) => !name.toLowerCase().includes(p),
      },

      // Digits / symbols (with small sets)
      {
        id: "has_any_digit",
        label: () => "ALLOWED if the name has any number (0–9).",
        genParams: () => [true],
        predicate: (name) => /\d/.test(name),
      },
      {
        id: "has_digits_subset_two",
        label: set => `ALLOWED if the name has ${set.join(" or ")}.`,
        genParams: () => shuffle(kCombinations(DIGITS,2)).slice(0,60),
        predicate: (name, set) => hasAny(name, set),
      },
      {
        id: "has_any_symbol",
        label: () => `ALLOWED if the name has any of: ${SYMBOLS.join(" ")}`,
        genParams: () => [true],
        predicate: (name) => SYMBOLS.some(sym => name.includes(sym)),
      },
      {
        id: "has_symbols_subset_two",
        label: set => `ALLOWED if the name has ${set.join(" or ")}.`,
        genParams: () => shuffle(kCombinations(SYMBOLS,2)).slice(0,40),
        predicate: (name, set) => set.some(sym => name.includes(sym)),
      },

      // Word form & simple patterns
      { id: "single_word", label: () => "ALLOWED if the name is a single word.", genParams: () => [true], predicate: (name) => singleWord(name) },
      { id: "multi_word",  label: () => "ALLOWED if the name has multiple words.", genParams: () => [true], predicate: (name) => hasSpace(name) },
      { id: "starts_with_vowel", label: () => "ALLOWED if the name starts with a vowel.", genParams: () => [true], predicate: (name) => startsWithVowel(name) },
      { id: "ends_with_vowel",   label: () => "ALLOWED if the name ends with a vowel.",   genParams: () => [true], predicate: (name) => endsWithVowel(name) },
      { id: "starts_with_consonant", label: () => "ALLOWED if the name starts with a consonant.", genParams: () => [true], predicate: (name) => startsWithConsonant(name) },
      { id: "ends_with_consonant",   label: () => "ALLOWED if the name ends with a consonant.",   genParams: () => [true], predicate: (name) => endsWithConsonant(name) },
      { id: "double_char", label: () => "ALLOWED if the name has a double letter/number (ee, ll, 11).", genParams: () => [true], predicate: (name) => doubleChar(name) },
    ];

    // Simple AND-compound rules (still human-easy)
    function compoundLabel(parts){ return "ALLOWED if " + parts.join(" AND "); }
    function compoundRule(id, labelBuilder, paramGen, predicate){ return { id, label: labelBuilder, genParams: paramGen, predicate }; }

    function buildCompoundRules(ctx){
      const letters = Object.keys(ctx.letterStats.counts);
      const bigramsTop = pickNearHalfFrom(Array.from(ctx.bigramStats.counts.entries()), ctx.bigramStats.total, "include").slice(0, 24);

      const rules = [];

      // A) Starts with vowel AND has a hyphen
      rules.push(compoundRule(
        "starts_vowel_and_hyphen",
        () => compoundLabel(["the name starts with a vowel","it has a hyphen"]),
        () => [true],
        (name) => startsWithVowel(name) && name.includes("-")
      ));

      // B) Single word AND has digits (1 or 2)
      const digitPairs = kCombinations(DIGITS.slice(0,3), 2); // 0–2 pairs like ["1","2"]
      rules.push(compoundRule(
        "singleword_and_digits_pair",
        p => compoundLabel(["the name is a single word", `it has ${p.join(" or ")}`]),
        () => digitPairs,
        (name, p) => singleWord(name) && hasAny(name, p)
      ));

      // C) Not starting with letter X AND ends with letter Y
      rules.push(compoundRule(
        "not_starts_X_ends_Y",
        p => compoundLabel([`it does NOT start with “${p.a.toUpperCase()}”`, `it ends with “${p.b.toUpperCase()}”`]),
        () => shuffle(kCombinations(letters,2)).slice(0,60).map(([a,b]) => ({a,b})),
        (name, p) => !startsWith(name, p.a) && endsWith(name, p.b)
      ));

      // D) Multi-word AND contains bigram “xy”
      rules.push(compoundRule(
        "multiword_and_bigram",
        p => compoundLabel(["the name has multiple words", `it contains “${p.bg}”`]),
        () => bigramsTop.map(bg => ({bg})),
        (name, p) => hasSpace(name) && name.toLowerCase().includes(p.bg)
      ));

      // E) No symbol subset AND ends with vowel
      const symPairs = kCombinations(SYMBOLS,2);
      rules.push(compoundRule(
        "no_syms_and_ends_vowel",
        p => compoundLabel([`it has NONE of ${p.syms.join(" or ")}`, "it ends with a vowel"]),
        () => shuffle(symPairs).slice(0,40).map(syms => ({syms})),
        (name, p) => p.syms.every(s => !name.includes(s)) && endsWithVowel(name)
      ));

      return rules;
    }

    // ----------------------------
    // Rule engine & constraints
    // ----------------------------
    function ruleKey(ruleId, params){
      const normalized = Array.isArray(params) ? [...params].sort() :
        (typeof params === "object" && params ? Object.keys(params).sort().reduce((o,k)=> (o[k]=params[k], o), {}) : params);
      return `${ruleId}::${toKey(normalized)}`;
    }

    function partition(items, predicate, params){
      const allowed=[], banned=[];
      for(const it of items){
        (predicate(it.name, params) ? allowed : banned).push(it);
      }
      return {allowed, banned};
    }

    function meetsGlobalBalance(allowed, banned){
      return allowed >= MIN_ALLOWED && banned >= MIN_BANNED;
    }

    function atLeastOneWeaponAllowed(allowedItems){
      if(!REQUIRE_AT_LEAST_ONE_WEAPON) return true;
      return allowedItems.some(it => it.category === "weapon");
    }

    // ----------------------------
    // Rendering (inline banned)
    // ----------------------------
    function renderByClass(allItems, allowedSet){
      const container = document.getElementById("byClass");
      container.innerHTML = "";
      // Build full map of all items by class & category to display all (allowed + banned)
      const grouped = {};
      for(const it of allItems){
        grouped[it.buildName] ??= { specialization:[], gadget:[], weapon:[] };
        grouped[it.buildName][it.category].push(it);
      }
      for(const [buildName, cats] of Object.entries(grouped)){
        const groupDiv = document.createElement("div"); groupDiv.className = "group";
        const cols = document.createElement("div"); cols.className = "cols";
        groupDiv.innerHTML = `<h3>${buildName}</h3>`;
        for(const cat of ["specialization","gadget","weapon"]){
          const block = document.createElement("div");
          block.innerHTML = `<div class="subhead">${cat[0].toUpperCase()+cat.slice(1)}</div>`;
          const ul = document.createElement("ul");
          for(const item of (cats[cat] || [])){
            const li = document.createElement("li");
            const isAllowed = allowedSet.has(item.id);
            if(!isAllowed) li.classList.add("banned");
            li.innerHTML = `<span>${item.name}</span><span class="id">#${item.id}</span>`;
            ul.appendChild(li);
          }
          block.appendChild(ul);
          cols.appendChild(block);
        }
        groupDiv.appendChild(cols);
        container.appendChild(groupDiv);
      }
    }

    function showCounts(a, b){
      const A = document.getElementById("countAllowed");
      const B = document.getElementById("countBanned");
      A.textContent = `Allowed: ${a}`;
      B.textContent = `Banned: ${b}`;
      A.className = `pill ${a>=MIN_ALLOWED ? "ok":"bad"}`;
      B.className = `pill ${b>=MIN_BANNED ? "ok":"bad"}`;
    }

    // ----------------------------
    // Generator
    // ----------------------------
    async function generateRuleAndRender(builds){
      const items = flattenItems(builds);

      const letterStats = makeLetterStats(items);
      const bigramStats = makeBigramStats(items);
      const ctx = { items, letterStats, bigramStats };

      const RULES = [...BASE_RULES, ...buildCompoundRules(ctx)];

      const used = loadUsedRules();
      const ruleOrder = shuffle([...RULES]);
      let chosen = null, chosenParams = null, part = null;

      outer:
      for(let attempts = 0; attempts < MAX_RULE_ATTEMPTS; attempts++){
        const rule = sample(ruleOrder);
        const paramsList = shuffle(rule.genParams(ctx));
        for(const p of paramsList){
          const key = ruleKey(rule.id, p);
          if(used.has(key)) continue;

          const res = partition(items, rule.predicate, p);
          if(!meetsGlobalBalance(res.allowed.length, res.banned.length)) continue;
          if(REQUIRE_AT_LEAST_ONE_WEAPON && !atLeastOneWeaponAllowed(res.allowed)) continue;

          chosen = rule; chosenParams = p; part = res;
          used.add(key); saveUsedRules(used);
          break outer;
        }
      }

      const ruleText = document.getElementById("ruleText");
      const cacheInfo = document.getElementById("cacheInfo");
      cacheInfo.textContent = `Seen rules: ${loadUsedRules().size}`;

      if(!chosen){
        ruleText.innerHTML = `<span class="error">Couldn’t find a new balanced rule. Try again or “Reset Rules Cache”.</span>`;
        showCounts(0,0);
        document.getElementById("byClass").innerHTML = "";
        return;
      }

      ruleText.textContent = chosen.label(chosenParams);

      // Build a Set of allowed IDs for inline rendering
      const allowedSet = new Set(part.allowed.map(i=>i.id));
      showCounts(part.allowed.length, part.banned.length);
      renderByClass(items, allowedSet);
    }

    // ----------------------------
    // UI
    // ----------------------------
    document.getElementById("newRuleBtn").addEventListener("click", async ()=>{
      try{
        document.getElementById("ruleText").textContent = "Finding a balanced rule…";
        await generateRuleAndRender(window.__DATA_BUILDS || []);
      }catch(err){
        document.getElementById("ruleText").innerHTML = `<span class="error">Error: ${err.message}</span>`;
      }
    });

    document.getElementById("resetCacheBtn").addEventListener("click", ()=>{
      resetUsedRules();
      document.getElementById("cacheInfo").textContent = "Seen rules: 0";
    });

    // ----------------------------
    // Init
    // ----------------------------
    (async function init(){
      try{
        const data = await fetchData();
        window.__DATA_BUILDS = Array.isArray(data) ? data : [];
        document.getElementById("ruleText").textContent = "Generating…";
        await generateRuleAndRender(window.__DATA_BUILDS);
      }catch(err){
        document.getElementById("ruleText").innerHTML = `<span class="error">Failed to load data: ${err.message}</span>`;
      }
    })();
  </script>
</body>
</html>
